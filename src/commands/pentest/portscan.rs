// src/commands/pentest/portscan.rs
use crate::commands::net::ping::ping_concurrent_async;
use crate::commands::pentest::fingerprint::load_fingerprints;
use crate::commands::pentest::port_handshake::*;
use crate::commands::pentest::port_list::*;
use crate::utils::{ScanProgress, parse_ports, parse_targets, save_to_excel};
use clap::Parser;
use futures::stream::{FuturesUnordered, StreamExt};
use std::error::Error;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::net::TcpStream;
use tokio::sync::{Mutex, Semaphore};

/// 端口扫描参数配置
#[derive(Parser, Debug)]
pub struct PortScan {
    /// 目标IP或IP段（支持CIDR、范围、多个IP用逗号隔开）
    ///
    /// 示例：
    /// - 单个IP: 192.168.1.1
    /// - 多个IP: 192.168.1.1,192.168.1.2
    /// - IP范围: 192.168.1.1-10
    /// - CIDR: 192.168.1.0/24
    #[arg(short, long, value_name = "TARGET")]
    pub targets: String,

    /// 自定义端口列表（用逗号隔开，支持范围）
    ///
    /// 示例：22,80,443,8000-9000
    #[arg(short, long, value_name = "PORTS")]
    pub ports: Option<String>,

    /// 扫描全部端口（1-65535）
    #[arg(long)]
    pub full: bool,

    /// 最大并发数
    #[arg(short = 'c', long, default_value = "200", value_name = "NUM")]
    pub concurrency: usize,

    /// 是否输出结果到Excel文件
    #[arg(short = 'o', long)]
    pub output: bool,

    /// 先进行主机存活探测（Ping扫描）
    #[arg(long)]
    pub live: bool,
}

/// 端口扫描结果
#[derive(Debug, Clone)]
pub struct PortScanResult {
    /// IP地址
    pub ip: String,
    /// 端口号
    pub port: u16,
    /// 状态（开放/关闭）
    pub status: String,
    /// 服务banner信息
    pub banner: String,
    /// 识别证据列表
    pub evidence: Vec<String>,
}

impl PortScanResult {
    /// 创建开放端口的结果
    fn open(ip: String, port: u16, banner: String, evidence: Vec<String>) -> Self {
        Self {
            ip,
            port,
            status: "开放".to_string(),
            banner,
            evidence,
        }
    }

    /// 创建关闭端口的结果
    fn closed(ip: String, port: u16) -> Self {
        Self {
            ip,
            port,
            status: "关闭".to_string(),
            banner: String::new(),
            evidence: Vec::new(),
        }
    }

    /// 检查端口是否开放
    pub fn is_open(&self) -> bool {
        self.status == "开放"
    }
}

/// 执行端口扫描
///
/// # 参数
/// * `args` - 端口扫描参数
///
/// # 返回
/// * `Ok(())` - 扫描成功完成
/// * `Err` - 扫描过程中发生错误
pub async fn run(args: &PortScan) -> Result<(), Box<dyn Error + Send + Sync>> {
    let start = Instant::now();

    // 加载指纹库
    let fps = load_fingerprints("fingerprints.yaml")?;

    // 解析目标IP列表
    let ips = parse_targets(&args.targets)?;

    // 如果启用了存活探测，先进行Ping扫描
    let live_ips = if args.live {
        println!("🔍 开始主机存活探测...");
        let ping_progress = ScanProgress::new(ips.len() as u64);
        let ping_results = ping_concurrent_async(ips.clone(), 3, 2, 100, &ping_progress).await?;

        let alive: Vec<String> = ping_results
            .into_iter()
            .filter(|r| r.is_success())
            .map(|r| r.ip)
            .collect();

        println!("✅ 发现 {} 个存活主机", alive.len());
        alive
    } else {
        ips
    };

    if live_ips.is_empty() {
        return Err("没有有效的IP地址可供扫描".into());
    }

    // 确定要扫描的端口列表
    let ports: Vec<u16> = if args.full {
        println!("⚠️  全端口扫描模式（1-65535）");
        (1..=65535).collect()
    } else if let Some(ref port_str) = args.ports {
        let parsed = parse_ports(port_str);
        if parsed.is_empty() {
            return Err("未解析到任何有效端口".into());
        }
        parsed
    } else {
        DEFAULT_PORTS.to_vec()
    };

    let total_tasks = (live_ips.len() * ports.len()) as u64;
    println!(
        "🔍 开始端口扫描: {} 个IP × {} 个端口 = {} 个任务",
        live_ips.len(),
        ports.len(),
        total_tasks
    );
    println!("⚙️  配置: 并发={}", args.concurrency);

    // 初始化结果存储和进度条
    let results = Arc::new(Mutex::new(Vec::<PortScanResult>::with_capacity(
        total_tasks as usize,
    )));
    let progress = ScanProgress::new(total_tasks);

    // 并发控制信号量
    let sem = Arc::new(Semaphore::new(args.concurrency));
    let mut tasks = FuturesUnordered::new();

    // 为每个IP和端口创建扫描任务
    for ip in live_ips {
        for &port in &ports {
            let permit = sem.clone().acquire_owned().await?;
            let ip_cloned = ip.clone();
            let results_clone = results.clone();
            let progress_clone = progress.clone();
            let fps_clone = fps.clone();

            tasks.push(tokio::spawn(async move {
                let _permit = permit;

                // 扫描单个端口
                let result = scan_single_port(&ip_cloned, port, &fps_clone, &progress_clone).await;

                // 保存结果
                {
                    let mut results_guard = results_clone.lock().await;
                    results_guard.push(result);
                }

                progress_clone.inc(1);
            }));
        }
    }

    // 等待所有任务完成
    while tasks.next().await.is_some() {}

    progress.finish_with_message("✅ 端口扫描完成");

    // 获取最终结果
    let final_results = Arc::try_unwrap(results)
        .expect("无法获取最终结果")
        .into_inner();

    // 统计结果
    let open_ports: Vec<&PortScanResult> = final_results.iter().filter(|r| r.is_open()).collect();

    let total_scanned = final_results.len();
    let open_count = open_ports.len();
    let closed_count = total_scanned - open_count;

    // 保存到Excel
    if args.output {
        save_to_excel(
            &final_results,
            &["IP地址", "端口", "状态", "服务", "证据"],
            |r| {
                vec![
                    r.ip.clone(),
                    r.port.to_string(),
                    r.status.clone(),
                    r.banner.clone(),
                    r.evidence.join("; "),
                ]
            },
            "portscan",
            "portscan",
        )?;
    }

    // 打印总结
    let elapsed = start.elapsed();
    println!("\n📊 扫描统计:");
    println!("   总计: {} 个端口", total_scanned);
    println!(
        "   开放: {} 个 ({:.1}%)",
        open_count,
        (open_count as f64 / total_scanned as f64) * 100.0
    );
    println!(
        "   关闭: {} 个 ({:.1}%)",
        closed_count,
        (closed_count as f64 / total_scanned as f64) * 100.0
    );
    println!("   耗时: {:.2?}", elapsed);

    // 按IP分组显示开放端口
    if open_count > 0 {
        println!("\n🔓 开放端口详情:");
        let mut grouped: std::collections::HashMap<String, Vec<&PortScanResult>> =
            std::collections::HashMap::new();
        for result in &open_ports {
            grouped.entry(result.ip.clone()).or_default().push(result);
        }

        for (ip, ports) in grouped.iter() {
            let port_list: Vec<String> = ports.iter().map(|p| p.port.to_string()).collect();
            println!("   {} => [{}]", ip, port_list.join(", "));
        }
    }

    Ok(())
}

/// 扫描单个端口
///
/// # 参数
/// * `ip` - IP地址
/// * `port` - 端口号
/// * `fps` - 指纹库
/// * `progress` - 进度条（用于输出信息）
///
/// # 返回
/// * `PortScanResult` - 扫描结果
async fn scan_single_port(
    ip: &str,
    port: u16,
    _fps: &[crate::commands::pentest::fingerprint::Fingerprint],
    progress: &ScanProgress,
) -> PortScanResult {
    let addr = format!("{}:{}", ip, port);
    let mut evidence: Vec<String> = Vec::new();
    let mut banner = String::new();

    // 尝试连接并读取banner
    if let Some(buf) = connect_and_read(
        &addr,
        Duration::from_secs(3),
        Duration::from_secs(2),
        Duration::from_millis(400),
        4096,
    )
    .await
    {
        // 识别协议和服务
        if buf.starts_with(b"SSH-") {
            if let Ok(s) = std::str::from_utf8(&buf) {
                banner = s.lines().next().unwrap_or("SSH").to_string();
                evidence.push("ssh-banner".to_string());
            }
        } else if is_mysql_handshake(&buf) {
            banner = extract_mysql_banner(&buf);
            evidence.push(format!("mysql-handshake (len={})", buf.len()));
        } else if is_rdp_response(&buf) {
            banner = extract_rdp_banner(&buf);
            evidence.push("rdp-response".to_string());
        } else {
            banner = extract_banner_text(&buf);
            evidence.push("initial-raw".to_string());
        }

        // 生成结果 - 端口开放
        if banner.trim().is_empty() {
            banner = "服务未知".to_string();
        }
        progress.println(format!(
            "  ✅ {}:{} | {} | {:?}",
            ip, port, banner, evidence
        ));
        PortScanResult::open(ip.to_string(), port, banner, evidence)
    } else {
        // 无直接banner，尝试协议探测
        let is_open = probe_specific_protocols(ip, port, &mut banner, &mut evidence).await;

        if is_open {
            if banner.trim().is_empty() {
                banner = "服务未知".to_string();
            }
            progress.println(format!(
                "  ✅ {}:{} | {} | {:?}",
                ip, port, banner, evidence
            ));
            PortScanResult::open(ip.to_string(), port, banner, evidence)
        } else {
            PortScanResult::closed(ip.to_string(), port)
        }
    }
}

/// 探测特定协议
///
/// # 参数
/// * `ip` - IP地址
/// * `port` - 端口号
/// * `banner` - 用于存储识别的服务信息
/// * `evidence` - 用于存储识别证据
///
/// # 返回
/// * `bool` - 端口是否开放
async fn probe_specific_protocols(
    ip: &str,
    port: u16,
    banner: &mut String,
    evidence: &mut Vec<String>,
) -> bool {
    let addr = format!("{}:{}", ip, port);

    // PostgreSQL探测
    if port == 5432 || port == 5433 {
        if let Some(p) = probe_postgres(&addr).await {
            *banner = p;
            evidence.push("postgres-sslrequest".to_string());
            return true;
        }
    }

    // MongoDB探测
    if port == 27017 {
        if let Some(p) = probe_mongo(&addr).await {
            *banner = p;
            evidence.push("mongo-opquery".to_string());
            return true;
        }
    }

    // Redis探测
    if port == 6379 {
        if let Ok(Ok(stream)) =
            tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr)).await
        {
            if let Some(p) = probe_redis(stream).await {
                *banner = p;
                evidence.push("redis-ping".to_string());
                return true;
            }
        }
    }

    // SSH探测
    if port == 22 {
        if let Ok(Ok(stream)) =
            tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr)).await
        {
            if let Some(p) = probe_ssh_banner(stream).await {
                *banner = p;
                evidence.push("ssh-banner".to_string());
                return true;
            }
        }
    }

    // HTTP/HTTPS探测（常见Web端口）
    if matches!(port, 80 | 443 | 8080 | 8443 | 8000 | 8888 | 3000) {
        if let Ok(Ok(_)) =
            tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr)).await
        {
            if let Some((h, ev)) = probe_http_services_connect(ip, port, &[]).await {
                *banner = h;
                evidence.extend(ev);
                return true;
            }
        }
    }

    // FTP探测
    if let Ok(Ok(stream)) =
        tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr)).await
    {
        if let Some(p) = probe_ftp(stream).await {
            *banner = p;
            evidence.push("ftp-banner".to_string());
            return true;
        }
    }

    false
}
