// src/commands/pentest/portscan.rs
use crate::commands::net::ping::ping_concurrent_async;
use crate::commands::pentest::port_handshake::*;
use crate::commands::pentest::port_list::*;
use crate::utils::{ScanProgress, parse_ports, parse_targets, save_to_excel};
use clap::Parser;
use futures::stream::{FuturesUnordered, StreamExt};
use std::error::Error;
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::net::TcpStream;
use tokio::sync::{Mutex, Semaphore};
use crate::commands::pentest::fingerprint::load_fingerprints;

#[derive(Parser, Debug)]
pub struct PortScan {
    /// IP æˆ– IP æ®µï¼ˆæ”¯æŒCIDRã€èŒƒå›´ã€å¤šä¸ªIPç”¨é€—å·éš”å¼€ï¼‰
    #[arg(short, long)]
    pub targets: String,

    /// è‡ªå®šä¹‰ç«¯å£ï¼ˆç”¨é€—å·éš”å¼€ï¼Œä¾‹å¦‚ï¼š80,443,22ï¼‰
    #[arg(short, long)]
    pub ports: Option<String>,

    /// æ˜¯å¦æ‰«æå…¨éƒ¨ç«¯å£ï¼ˆ1-65535ï¼‰
    #[arg(long, default_value = "false")]
    pub full: bool,

    /// æœ€å¤§å¹¶å‘æ•°
    #[arg(short = 'c', long, default_value = "200")]
    pub concurrency: usize,

    /// è¾“å‡ºåˆ°excel
    #[arg(long, default_value = "false")]
    pub output: bool,

    /// ä¸»æœºå­˜æ´»æ¢æµ‹
    #[arg(long, default_value = "false")]
    pub live: bool,
}

#[derive(Debug, Clone)]
pub struct PortScanResult {
    pub ip: String,
    pub port: u16,
    pub status: String,
    pub banner: String,
    pub evidence: Vec<String>,
}


pub async fn run(args: &PortScan) -> Result<(), Box<dyn Error + Send + Sync>> {
    let fps = load_fingerprints("fingerprints.yaml")?;

    let start = Instant::now();

    let ips = parse_targets(&args.targets)?;
    let live_ips: Vec<String>;
    if args.live {
        let ping_results = ping_concurrent_async(
            ips.clone(),
            3,
            2,
            100,
            &mut ScanProgress::new(ips.len() as u64),
        )
            .await?;
        live_ips = ping_results
            .into_iter()
            .filter(|r| r.status == "æˆåŠŸ")
            .map(|r| r.ip)
            .collect();
    } else {
        live_ips = ips.clone();
    }

    let ports: Vec<u16> = if args.full {
        (1..=65535).collect()
    } else if let Some(pstr) = &args.ports {
        parse_ports(pstr)
    } else {
        DEFAULT_PORTS.to_vec()
    };

    if live_ips.is_empty() {
        println!("æ²¡æœ‰æœ‰æ•ˆçš„ IP åœ°å€å¯ä¾›æ‰«æ");
        return Ok(());
    }

    let total_tasks = (live_ips.len() * ports.len()) as u64;
    println!("ğŸ” å…± {} ä¸ªIPï¼Œ{} ä¸ªç«¯å£å¾…æ‰«æ", live_ips.len(), total_tasks);

    let result_arc = Arc::new(Mutex::new(Vec::<PortScanResult>::new()));
    let progress = ScanProgress::new(total_tasks);

    // concurrency æ§åˆ¶
    let sem = Arc::new(Semaphore::new(args.concurrency));
    let mut tasks = FuturesUnordered::new();

    for ip in live_ips {
        for &port in &ports {
            let permit = sem.clone().acquire_owned().await.unwrap();
            let ip_cloned = ip.clone();
            let result_arc = result_arc.clone();
            let progress = progress.clone();
            let fps = fps.clone();

            tasks.push(tokio::spawn(async move {
                let _permit = permit;

                let socket = format!("{}:{}", ip_cloned, port);
                let _addr: SocketAddr = match socket.parse() {
                    Ok(a) => a,
                    Err(_) => {
                        progress.inc();
                        return;
                    }
                };

                let mut evidence: Vec<String> = Vec::new();
                let mut banner = String::new();
                let mut status = "å…³é—­".to_string();

                // å…ˆåš connect+read å°è¯•å¿«é€ŸæŠ“å– banner
                let addr_str = format!("{}:{}", ip_cloned, port);
                if let Some(buf) = connect_and_read(
                    &addr_str,
                    Duration::from_secs(3),
                    Duration::from_secs(2),
                    Duration::from_millis(400),
                    4096,
                )
                    .await
                {
                    // æœ‰ç›´æ¥è¿”å›çš„æ•°æ®ï¼Œä¼˜å…ˆè§£æ
                    if buf.starts_with(b"SSH-") {
                        if let Ok(s) = std::str::from_utf8(&buf) {
                            banner = s.lines().next().unwrap_or("").to_string();
                            evidence.push("ssh-banner".to_string());
                            status = "å¼€æ”¾".to_string();
                        }
                    } else if is_mysql_handshake(&buf) {
                        banner = extract_mysql_banner(&buf);
                        evidence.push(format!("mysql-handshake (len={})", buf.len()));
                        status = "å¼€æ”¾".to_string();
                    } else if is_rdp_response(&buf) {
                        banner = extract_rdp_banner(&buf);
                        evidence.push("rdp-response".to_string());
                        status = "å¼€æ”¾".to_string();
                    } else {
                        // å¯èƒ½æ˜¯ HTTP æˆ–å…¶å®ƒåè®®ï¼šäº¤ç»™ HTTP / æŒ‡çº¹æ¢æµ‹
                        // fallback to raw ascii as banner
                        let preview = extract_banner_text(&buf);
                        banner = preview.clone();
                        evidence.push("initial-raw".to_string());
                        status = "å¼€æ”¾".to_string();
                    }
                } else {
                    // connect failed or no banner; decide whether to attempt protocol-specific probes based on port
                    // å°è¯•ç‰¹å®šç«¯å£çš„ probe (é¡ºåºæŒ‰å¯èƒ½æ€§)
                    let addr_for_probe = format!("{}:{}", ip_cloned, port);
                    // Try Postgres (default 5432)
                    let mut probe_done = false;
                    if !probe_done && (port == 5432 || port == 5433) {
                        if let Some(p) = probe_postgres(&addr_for_probe).await {
                            banner = p.clone();
                            evidence.push("postgres-sslrequest".to_string());
                            status = "å¼€æ”¾".to_string();
                            probe_done = true;
                        }
                    }
                    // Try MongoDB (27017)
                    if !probe_done && (port == 27017) {
                        if let Some(p) = probe_mongo(&addr_for_probe).await {
                            banner = p.clone();
                            evidence.push("mongo-opquery".to_string());
                            status = "å¼€æ”¾".to_string();
                            probe_done = true;
                        }
                    }
                    // Try Redis (6379)
                    if !probe_done && (port == 6379) {
                        if let Ok(stream) = tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr_for_probe)).await {
                            if let Ok(s) = stream {
                                if let Some(p) = probe_redis(s).await {
                                    banner = p.clone();
                                    evidence.push("redis-ping".to_string());
                                    status = "å¼€æ”¾".to_string();
                                    probe_done = true;
                                }
                            }
                        }
                    }
                    // Try SSH (22)
                    if !probe_done && port == 22 {
                        if let Ok(stream) = tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr_for_probe)).await {
                            if let Ok(s) = stream {
                                if let Some(p) = probe_ssh_banner(s).await {
                                    banner = p.clone();
                                    evidence.push("ssh-banner".to_string());
                                    status = "å¼€æ”¾".to_string();
                                    probe_done = true;
                                }
                            }
                        }
                    }

                    // è‹¥ä¸Šé¢æ²¡æœ‰è¯†åˆ«ï¼Œå°è¯• HTTP probeï¼ˆå¯¹å¸¸è§ web ç«¯å£ï¼‰
                    if !probe_done && (port == 80 || port == 8080 || port == 8000 || port == 8888 || port == 443 || port == 8443 || port == 3000) {
                        if let Ok(stream) = tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr_for_probe)).await {
                            if let Ok(_s) = stream {
                                if let Some((h, ev)) = probe_http_services_connect(&ip_cloned, port, &fps).await {
                                    banner = h.clone();
                                    evidence.extend(ev);
                                    status = "å¼€æ”¾".to_string();
                                    probe_done = true;
                                }
                            }
                        }
                    }

                    // å¦‚æœä»ç„¶æ²¡æœ‰è¯†åˆ«ï¼Œå°è¯•é€šç”¨ connect + small probes (SMTP/FTP/POP3)
                    if !probe_done {
                        if let Ok(stream) = tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr_for_probe)).await {
                            if let Ok(s) = stream {
                                // FTP
                                if let Some(p) = probe_ftp(s).await {
                                    banner = p.clone();
                                    evidence.push("ftp-banner".to_string());
                                    status = "å¼€æ”¾".to_string();
                                    // probe_done = true;
                                }
                            }
                        }
                    }
                } // end else (no immediate banner)

                // å¦‚æœåˆå§‹è§£ææ˜¾ç¤ºå¼€æ”¾åˆ™ final open
                if status == "å¼€æ”¾" && banner.trim().is_empty() {
                    banner = "å¼€æ”¾ æœåŠ¡æœªçŸ¥".to_string();
                }

                if status == "å¼€æ”¾" {
                    progress.println(format!("{} => {:<5} | å¼€æ”¾ | æœåŠ¡: {} | è¯æ®: {:?}", ip_cloned, port, banner, evidence));
                }

                // push result
                {
                    let mut results = result_arc.lock().await;
                    results.push(PortScanResult {
                        ip: ip_cloned,
                        port,
                        status,
                        banner,
                        evidence,
                    });
                }

                progress.inc();
            }));
        }
    }

    // await tasks
    while let Some(_) = tasks.next().await {}

    progress.finish();

    let results = Arc::try_unwrap(result_arc).unwrap().into_inner();

    if args.output {
        save_to_excel(
            &results,
            &["IPåœ°å€", "ç«¯å£", "çŠ¶æ€", "æœåŠ¡", "è¯æ®"],
            |r| {
                vec![
                    r.ip.clone(),
                    r.port.to_string(),
                    r.status.clone(),
                    r.banner.clone(),
                    r.evidence.join("; "),
                ]
            },
            "portscan",
            "portscan",
        )?;
    }

    let elapsed = start.elapsed();
    println!(
        "âœ… æ‰«æå®Œæˆï¼Œå…±å‘ç° {} ä¸ªå¼€æ”¾ç«¯å£",
        results.iter().filter(|r| r.status == "å¼€æ”¾").count()
    );
    println!("â±ï¸ æ€»è€—æ—¶ï¼š{elapsed:.2?}");

    Ok(())
}
