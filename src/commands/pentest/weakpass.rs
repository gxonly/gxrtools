// src/commands/pentest/weakpass.rs
use crate::utils::{ScanProgress, parse_targets, save_to_excel};
use clap::Parser;
use futures::stream::{FuturesUnordered, StreamExt};
use reqwest::Client as HttpClient;
use ssh2::Session;
use std::error::Error;
use std::fs;

use std::net::TcpStream;
use std::path::Path;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{Mutex, Semaphore};

/// å¼±å£ä»¤æ‰«æå‚æ•°
#[derive(Parser, Debug, Clone)]
pub struct WeakPassArgs {
    /// ç›®æ ‡IPæˆ–IPæ®µï¼ˆæ”¯æŒCIDRã€èŒƒå›´ã€å¤šä¸ªIPç”¨é€—å·éš”å¼€ï¼‰
    #[arg(short, long, value_name = "TARGET")]
    pub targets: String,

    /// æœåŠ¡ç±»å‹ï¼ˆssh, rdp, tomcat, nacos, web, allï¼‰
    #[arg(short, long, default_value = "all", value_name = "SERVICE")]
    pub service: String,

    /// ç”¨æˆ·åï¼ˆå­—ç¬¦ä¸²æˆ–.txtå­—å…¸æ–‡ä»¶ï¼‰
    #[arg(short, long, default_value = "usernames.txt", value_name = "USER")]
    pub usernames: String,

    /// å¯†ç ï¼ˆå­—ç¬¦ä¸²æˆ–.txtå­—å…¸æ–‡ä»¶ï¼‰
    #[arg(short, long, default_value = "passwords.txt", value_name = "PASS")]
    pub passwords: String,

    /// æœ€å¤§å¹¶å‘æ•°
    #[arg(short = 'c', long, default_value = "10", value_name = "NUM")]
    pub concurrency: usize,

    /// è¿æ¥è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    #[arg(short = 'T', long, default_value = "5", value_name = "SECS")]
    pub timeout: u64,

    /// æ˜¯å¦è¾“å‡ºç»“æœåˆ°Excel
    #[arg(short = 'o', long)]
    pub output: bool,
}

/// å¼±å£ä»¤æ‰«æç»“æœ
#[derive(Debug, Clone)]
pub struct WeakPassResult {
    pub ip: String,
    pub port: u16,
    pub service: String,
    pub username: String,
    pub password: String,
    pub status: String,
    pub details: String,
}

impl WeakPassResult {
    fn success(
        ip: String,
        port: u16,
        service: String,
        username: String,
        password: String,
        details: String,
    ) -> Self {
        Self {
            ip,
            port,
            service,
            username,
            password,
            status: "æˆåŠŸ".to_string(),
            details,
        }
    }
    #[allow(dead_code)]
    fn failed(ip: String, port: u16, service: String) -> Self {
        Self {
            ip,
            port,
            service,
            username: String::new(),
            password: String::new(),
            status: "å¤±è´¥".to_string(),
            details: String::new(),
        }
    }
}

/// æ‰§è¡Œå¼±å£ä»¤æ‰«æ
pub async fn run(args: &WeakPassArgs) -> Result<(), Box<dyn Error + Send + Sync>> {
    let start = Instant::now();

    println!("ğŸ” å¼€å§‹å¼±å£ä»¤æ‰«æ...");

    // è§£æç›®æ ‡IP
    let ips = parse_targets(&args.targets)?;
    if ips.is_empty() {
        return Err("æœªè§£æåˆ°ä»»ä½•æœ‰æ•ˆçš„IPåœ°å€".into());
    }

    // åŠ è½½ç”¨æˆ·åå’Œå¯†ç ï¼ˆæ”¯æŒå­—ç¬¦ä¸²æˆ–å­—å…¸æ–‡ä»¶ï¼‰
    let usernames = load_dict_or_string(&args.usernames)?;
    let passwords = load_dict_or_string(&args.passwords)?;

    if usernames.is_empty() {
        return Err("ç”¨æˆ·åå­—å…¸ä¸ºç©º".into());
    }
    if passwords.is_empty() {
        return Err("å¯†ç å­—å…¸ä¸ºç©º".into());
    }

    println!(
        "ğŸ“š åŠ è½½å­—å…¸: {} ä¸ªç”¨æˆ·å, {} ä¸ªå¯†ç ",
        usernames.len(),
        passwords.len()
    );
    println!("ğŸ¯ ç›®æ ‡æœåŠ¡: {}", args.service);
    println!(
        "âš™ï¸  é…ç½®: å¹¶å‘={}, è¶…æ—¶={}ç§’",
        args.concurrency, args.timeout
    );

    // ç¡®å®šè¦æ‰«æçš„æœåŠ¡å’Œç«¯å£
    let targets = generate_targets(&ips, &args.service)?;
    let total_tasks = targets.len() * usernames.len() * passwords.len();

    println!(
        "ğŸ” æ‰«æä»»åŠ¡: {} ä¸ªç›®æ ‡ Ã— {} ä¸ªç”¨æˆ· Ã— {} ä¸ªå¯†ç  = {} ä¸ªä»»åŠ¡",
        targets.len(),
        usernames.len(),
        passwords.len(),
        total_tasks
    );

    // åˆå§‹åŒ–
    let results = Arc::new(Mutex::new(Vec::<WeakPassResult>::new()));
    let progress = ScanProgress::new(total_tasks as u64);
    let sem = Arc::new(Semaphore::new(args.concurrency));
    let mut tasks = FuturesUnordered::new();

    // åˆ›å»ºæ‰«æä»»åŠ¡
    for (ip, port, service) in targets {
        for username in &usernames {
            for password in &passwords {
                let permit = sem.clone().acquire_owned().await?;
                let ip_clone = ip.clone();
                let service_clone = service.clone();
                let username_clone = username.clone();
                let password_clone = password.clone();
                let results_clone = results.clone();
                let progress_clone = progress.clone();
                let timeout = args.timeout;

                tasks.push(tokio::spawn(async move {
                    let _permit = permit;

                    let result = scan_credential(
                        &ip_clone,
                        port,
                        &service_clone,
                        &username_clone,
                        &password_clone,
                        timeout,
                    )
                    .await;

                    if let Some(r) = result {
                        progress_clone.println(format!(
                            "  âœ… å‘ç°å¼±å£ä»¤: {}:{} [{}] {}:{}",
                            r.ip, r.port, r.service, r.username, r.password
                        ));
                        let mut results_guard = results_clone.lock().await;
                        results_guard.push(r);
                    }

                    progress_clone.inc(1);
                }));
            }
        }
    }

    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    while tasks.next().await.is_some() {}

    progress.finish_with_message("âœ… å¼±å£ä»¤æ‰«æå®Œæˆ");

    // è·å–ç»“æœ
    let final_results = Arc::try_unwrap(results)
        .expect("æ— æ³•è·å–æœ€ç»ˆç»“æœ")
        .into_inner();

    let success_count = final_results.iter().filter(|r| r.status == "æˆåŠŸ").count();

    // ä¿å­˜ç»“æœ
    if args.output && !final_results.is_empty() {
        save_to_excel(
            &final_results,
            &["IPåœ°å€", "ç«¯å£", "æœåŠ¡", "ç”¨æˆ·å", "å¯†ç ", "çŠ¶æ€", "è¯¦æƒ…"],
            |r| {
                vec![
                    r.ip.clone(),
                    r.port.to_string(),
                    r.service.clone(),
                    r.username.clone(),
                    r.password.clone(),
                    r.status.clone(),
                    r.details.clone(),
                ]
            },
            "weakpass",
            "weakpass",
        )?;
    }

    // æ‰“å°ç»Ÿè®¡
    let elapsed = start.elapsed();
    println!("\nğŸ“Š æ‰«æç»Ÿè®¡:");
    println!("   æ€»ä»»åŠ¡: {}", total_tasks);
    println!("   å‘ç°å¼±å£ä»¤: {} ä¸ª", success_count);
    println!("   è€—æ—¶: {:.2?}", elapsed);

    if success_count > 0 {
        println!("\nğŸ”“ å¼±å£ä»¤è¯¦æƒ…:");
        for result in &final_results {
            if result.status == "æˆåŠŸ" {
                println!(
                    "   {}:{} [{}] {}:{} - {}",
                    result.ip,
                    result.port,
                    result.service,
                    result.username,
                    result.password,
                    result.details
                );
            }
        }
    }

    Ok(())
}

/// åŠ è½½å­—å…¸æ–‡ä»¶æˆ–è§£æå­—ç¬¦ä¸²
/// å¦‚æœå‚æ•°ä»¥.txtç»“å°¾ï¼Œåˆ™ä½œä¸ºå­—å…¸æ–‡ä»¶åŠ è½½
/// å¦åˆ™ä½œä¸ºå•ä¸ªå­—ç¬¦ä¸²å¤„ç†ï¼ˆæ”¯æŒé€—å·åˆ†éš”å¤šä¸ªå€¼ï¼‰
fn load_dict_or_string(input: &str) -> Result<Vec<String>, Box<dyn Error + Send + Sync>> {
    // æ£€æŸ¥æ˜¯å¦æ˜¯.txtæ–‡ä»¶
    if input.ends_with(".txt") {
        // ä½œä¸ºå­—å…¸æ–‡ä»¶å¤„ç†
        if !Path::new(input).exists() {
            eprintln!("âš ï¸  å­—å…¸æ–‡ä»¶ä¸å­˜åœ¨: {}ï¼Œä½¿ç”¨é»˜è®¤å­—å…¸", input);
            return Ok(get_default_dict(input));
        }

        let content = fs::read_to_string(input)?;
        let dict: Vec<String> = content
            .lines()
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty() && !s.starts_with('#'))
            .collect();

        if dict.is_empty() {
            return Err(format!("å­—å…¸æ–‡ä»¶ {} ä¸ºç©º", input).into());
        }

        Ok(dict)
    } else {
        // ä½œä¸ºå­—ç¬¦ä¸²å¤„ç†ï¼Œæ”¯æŒé€—å·åˆ†éš”
        let items: Vec<String> = input
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();

        if items.is_empty() {
            return Err("ç”¨æˆ·åæˆ–å¯†ç ä¸èƒ½ä¸ºç©º".into());
        }

        Ok(items)
    }
}

/// è·å–é»˜è®¤å­—å…¸
fn get_default_dict(path: &str) -> Vec<String> {
    if path.contains("username") {
        vec![
            "admin".to_string(),
            "root".to_string(),
            "administrator".to_string(),
            "user".to_string(),
            "test".to_string(),
            "nacos".to_string(),
            "tomcat".to_string(),
        ]
    } else {
        vec![
            "admin".to_string(),
            "password".to_string(),
            "123456".to_string(),
            "admin123".to_string(),
            "root".to_string(),
            "123456789".to_string(),
            "nacos".to_string(),
            "tomcat".to_string(),
            "".to_string(), // ç©ºå¯†ç 
        ]
    }
}

/// ç”Ÿæˆæ‰«æç›®æ ‡åˆ—è¡¨ (IP, Port, Service)
fn generate_targets(
    ips: &[String],
    service: &str,
) -> Result<Vec<(String, u16, String)>, Box<dyn Error + Send + Sync>> {
    let mut targets = Vec::new();

    for ip in ips {
        match service.to_lowercase().as_str() {
            "ssh" => targets.push((ip.clone(), 22, "SSH".to_string())),
            "rdp" => targets.push((ip.clone(), 3389, "RDP".to_string())),
            "tomcat" => {
                targets.push((ip.clone(), 8080, "Tomcat".to_string()));
                targets.push((ip.clone(), 8009, "Tomcat-AJP".to_string()));
            }
            "nacos" => targets.push((ip.clone(), 8848, "Nacos".to_string())),
            "web" => {
                targets.push((ip.clone(), 80, "HTTP".to_string()));
                targets.push((ip.clone(), 443, "HTTPS".to_string()));
                targets.push((ip.clone(), 8080, "HTTP-Alt".to_string()));
            }
            "all" => {
                targets.push((ip.clone(), 22, "SSH".to_string()));
                targets.push((ip.clone(), 3389, "RDP".to_string()));
                targets.push((ip.clone(), 8080, "Tomcat".to_string()));
                targets.push((ip.clone(), 8848, "Nacos".to_string()));
            }
            _ => return Err(format!("ä¸æ”¯æŒçš„æœåŠ¡ç±»å‹: {}", service).into()),
        }
    }

    Ok(targets)
}

/// æ‰«æå•ä¸ªå‡­è¯
async fn scan_credential(
    ip: &str,
    port: u16,
    service: &str,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    match service {
        "SSH" => check_ssh(ip, port, username, password, timeout).await,
        "RDP" => check_rdp(ip, port, username, password, timeout).await,
        "Tomcat" => check_tomcat(ip, port, username, password, timeout).await,
        "Nacos" => check_nacos(ip, port, username, password, timeout).await,
        "HTTP" | "HTTPS" | "HTTP-Alt" => {
            check_web_common(ip, port, username, password, timeout, service).await
        }
        _ => None,
    }
}

/// SSH å¼±å£ä»¤æ£€æµ‹
async fn check_ssh(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    let addr = format!("{}:{}", ip, port);
    let username_clone = username.to_string();
    let password_clone = password.to_string();
    let ip_clone = ip.to_string();

    // ä½¿ç”¨ tokio::task::spawn_blocking åœ¨é˜»å¡çº¿ç¨‹ä¸­æ‰§è¡Œ SSH è¿æ¥
    let result = tokio::task::spawn_blocking(move || {
        let tcp =
            TcpStream::connect_timeout(&addr.parse().ok()?, Duration::from_secs(timeout)).ok()?;
        tcp.set_read_timeout(Some(Duration::from_secs(timeout)))
            .ok()?;
        tcp.set_write_timeout(Some(Duration::from_secs(timeout)))
            .ok()?;

        let mut session = Session::new().ok()?;
        session.set_tcp_stream(tcp);
        session.set_timeout((timeout * 1000) as u32);
        session.handshake().ok()?;

        // å°è¯•å¯†ç è®¤è¯
        if session
            .userauth_password(&username_clone, &password_clone)
            .is_ok()
            && session.authenticated()
        {
            return Some(());
        }
        None
    })
    .await
    .ok()?;

    if result.is_some() {
        Some(WeakPassResult::success(
            ip_clone,
            port,
            "SSH".to_string(),
            username.to_string(),
            password.to_string(),
            "SSHè®¤è¯æˆåŠŸ".to_string(),
        ))
    } else {
        None
    }
}

/// RDP å¼±å£ä»¤æ£€æµ‹ï¼ˆåŸºç¡€ç«¯å£æ¢æµ‹ï¼‰
async fn check_rdp(
    ip: &str,
    port: u16,
    _username: &str,
    _password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    // æ³¨æ„ï¼šå®Œæ•´çš„ RDP è®¤è¯éœ€è¦å¤æ‚çš„åè®®å®ç°
    // è¿™é‡Œä»…åšç«¯å£è¿é€šæ€§æ£€æµ‹ä½œä¸ºç¤ºä¾‹
    let addr = format!("{}:{}", ip, port);

    match tokio::time::timeout(
        Duration::from_secs(timeout),
        tokio::net::TcpStream::connect(&addr),
    )
    .await
    {
        Ok(Ok(_stream)) => {
            // RDP ç«¯å£å¼€æ”¾ï¼Œä½†å®é™…è®¤è¯éœ€è¦ RDP åè®®åº“
            // è¿™é‡Œåªæ ‡è®°ç«¯å£å¼€æ”¾ï¼Œå®é™…é¡¹ç›®ä¸­åº”é›†æˆ RDP è®¤è¯åº“
            None
        }
        _ => None,
    }
}

/// Tomcat Manager å¼±å£ä»¤æ£€æµ‹
async fn check_tomcat(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    let urls = vec![
        format!("http://{}:{}/manager/html", ip, port),
        format!("http://{}:{}/manager/text", ip, port),
        format!("http://{}:{}/host-manager/html", ip, port),
    ];

    let client = HttpClient::builder()
        .timeout(Duration::from_secs(timeout))
        .danger_accept_invalid_certs(true)
        .build()
        .ok()?;

    for url in urls {
        let response = client
            .get(&url)
            .basic_auth(username, Some(password))
            .send()
            .await
            .ok()?;

        if response.status().is_success() {
            let body = response.text().await.ok()?;
            if body.contains("Tomcat") || body.contains("Manager") {
                return Some(WeakPassResult::success(
                    ip.to_string(),
                    port,
                    "Tomcat".to_string(),
                    username.to_string(),
                    password.to_string(),
                    format!("Tomcat Manager è®¿é—®æˆåŠŸ: {}", url),
                ));
            }
        }
    }

    None
}

/// Nacos å¼±å£ä»¤æ£€æµ‹
async fn check_nacos(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    let login_url = format!("http://{}:{}/nacos/v1/auth/login", ip, port);

    let client = HttpClient::builder()
        .timeout(Duration::from_secs(timeout))
        .danger_accept_invalid_certs(true)
        .build()
        .ok()?;

    let params = [("username", username), ("password", password)];

    let response = client.post(&login_url).form(&params).send().await.ok()?;

    if response.status().is_success() {
        let body = response.text().await.ok()?;
        if body.contains("accessToken") || body.contains("tokenTtl") {
            return Some(WeakPassResult::success(
                ip.to_string(),
                port,
                "Nacos".to_string(),
                username.to_string(),
                password.to_string(),
                "Nacos ç™»å½•æˆåŠŸ".to_string(),
            ));
        }
    }

    None
}

/// é€šç”¨ Web åº”ç”¨å¼±å£ä»¤æ£€æµ‹
async fn check_web_common(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
    service: &str,
) -> Option<WeakPassResult> {
    // å¸¸è§çš„ç™»å½•è·¯å¾„
    let login_paths = vec![
        "/login",
        "/admin",
        "/admin/login",
        "/user/login",
        "/auth/login",
        "/api/login",
        "/console",
        "/manage",
    ];

    let protocol = if port == 443 { "https" } else { "http" };

    let client = HttpClient::builder()
        .timeout(Duration::from_secs(timeout))
        .danger_accept_invalid_certs(true)
        .redirect(reqwest::redirect::Policy::limited(3))
        .build()
        .ok()?;

    for path in login_paths {
        let url = format!("{}://{}:{}{}", protocol, ip, port, path);

        // å°è¯• HTTP Basic Auth
        if let Ok(response) = client
            .get(&url)
            .basic_auth(username, Some(password))
            .send()
            .await
        {
            if response.status().is_success() {
                return Some(WeakPassResult::success(
                    ip.to_string(),
                    port,
                    service.to_string(),
                    username.to_string(),
                    password.to_string(),
                    format!("Basic Auth æˆåŠŸ: {}", url),
                ));
            }
        }

        // å°è¯• POST è¡¨å•ç™»å½•
        let post_data = [
            ("username", username),
            ("password", password),
            ("user", username),
            ("pass", password),
        ];

        if let Ok(response) = client.post(&url).form(&post_data).send().await {
            let body = response.text().await.ok()?;
            // æ£€æŸ¥ç™»å½•æˆåŠŸçš„å¸¸è§æ ‡è¯†
            if body.contains("success")
                || body.contains("dashboard")
                || body.contains("welcome")
                || (body.contains("token") && !body.contains("error"))
            {
                return Some(WeakPassResult::success(
                    ip.to_string(),
                    port,
                    service.to_string(),
                    username.to_string(),
                    password.to_string(),
                    format!("è¡¨å•ç™»å½•æˆåŠŸ: {}", url),
                ));
            }
        }
    }

    None
}
