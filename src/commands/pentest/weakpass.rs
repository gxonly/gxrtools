// src/commands/pentest/weakpass.rs
use crate::utils::{ScanProgress, parse_targets, save_to_excel};
use clap::Parser;
use futures::stream::{FuturesUnordered, StreamExt};
use reqwest::Client as HttpClient;
use ssh2::Session;
use std::error::Error;
use std::fs;

use std::net::TcpStream;
use std::path::Path;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{Mutex, Semaphore};

/// 弱口令扫描参数
#[derive(Parser, Debug, Clone)]
pub struct WeakPassArgs {
    /// 目标IP或IP段（支持CIDR、范围、多个IP用逗号隔开）
    #[arg(short, long, value_name = "TARGET")]
    pub targets: String,

    /// 服务类型（ssh, rdp, tomcat, nacos, web, all）
    #[arg(short, long, default_value = "all", value_name = "SERVICE")]
    pub service: String,

    /// 用户名（字符串或.txt字典文件）
    #[arg(short, long, default_value = "usernames.txt", value_name = "USER")]
    pub usernames: String,

    /// 密码（字符串或.txt字典文件）
    #[arg(short, long, default_value = "passwords.txt", value_name = "PASS")]
    pub passwords: String,

    /// 最大并发数
    #[arg(short = 'c', long, default_value = "10", value_name = "NUM")]
    pub concurrency: usize,

    /// 连接超时时间（秒）
    #[arg(short = 'T', long, default_value = "5", value_name = "SECS")]
    pub timeout: u64,

    /// 是否输出结果到Excel
    #[arg(short = 'o', long)]
    pub output: bool,
}

/// 弱口令扫描结果
#[derive(Debug, Clone)]
pub struct WeakPassResult {
    pub ip: String,
    pub port: u16,
    pub service: String,
    pub username: String,
    pub password: String,
    pub status: String,
    pub details: String,
}

impl WeakPassResult {
    fn success(
        ip: String,
        port: u16,
        service: String,
        username: String,
        password: String,
        details: String,
    ) -> Self {
        Self {
            ip,
            port,
            service,
            username,
            password,
            status: "成功".to_string(),
            details,
        }
    }
    #[allow(dead_code)]
    fn failed(ip: String, port: u16, service: String) -> Self {
        Self {
            ip,
            port,
            service,
            username: String::new(),
            password: String::new(),
            status: "失败".to_string(),
            details: String::new(),
        }
    }
}

/// 执行弱口令扫描
pub async fn run(args: &WeakPassArgs) -> Result<(), Box<dyn Error + Send + Sync>> {
    let start = Instant::now();

    println!("🔍 开始弱口令扫描...");

    // 解析目标IP
    let ips = parse_targets(&args.targets)?;
    if ips.is_empty() {
        return Err("未解析到任何有效的IP地址".into());
    }

    // 加载用户名和密码（支持字符串或字典文件）
    let usernames = load_dict_or_string(&args.usernames)?;
    let passwords = load_dict_or_string(&args.passwords)?;

    if usernames.is_empty() {
        return Err("用户名字典为空".into());
    }
    if passwords.is_empty() {
        return Err("密码字典为空".into());
    }

    println!(
        "📚 加载字典: {} 个用户名, {} 个密码",
        usernames.len(),
        passwords.len()
    );
    println!("🎯 目标服务: {}", args.service);
    println!(
        "⚙️  配置: 并发={}, 超时={}秒",
        args.concurrency, args.timeout
    );

    // 确定要扫描的服务和端口
    let targets = generate_targets(&ips, &args.service)?;
    let total_tasks = targets.len() * usernames.len() * passwords.len();

    println!(
        "🔍 扫描任务: {} 个目标 × {} 个用户 × {} 个密码 = {} 个任务",
        targets.len(),
        usernames.len(),
        passwords.len(),
        total_tasks
    );

    // 初始化
    let results = Arc::new(Mutex::new(Vec::<WeakPassResult>::new()));
    let progress = ScanProgress::new(total_tasks as u64);
    let sem = Arc::new(Semaphore::new(args.concurrency));
    let mut tasks = FuturesUnordered::new();

    // 创建扫描任务
    for (ip, port, service) in targets {
        for username in &usernames {
            for password in &passwords {
                let permit = sem.clone().acquire_owned().await?;
                let ip_clone = ip.clone();
                let service_clone = service.clone();
                let username_clone = username.clone();
                let password_clone = password.clone();
                let results_clone = results.clone();
                let progress_clone = progress.clone();
                let timeout = args.timeout;

                tasks.push(tokio::spawn(async move {
                    let _permit = permit;

                    let result = scan_credential(
                        &ip_clone,
                        port,
                        &service_clone,
                        &username_clone,
                        &password_clone,
                        timeout,
                    )
                    .await;

                    if let Some(r) = result {
                        progress_clone.println(format!(
                            "  ✅ 发现弱口令: {}:{} [{}] {}:{}",
                            r.ip, r.port, r.service, r.username, r.password
                        ));
                        let mut results_guard = results_clone.lock().await;
                        results_guard.push(r);
                    }

                    progress_clone.inc(1);
                }));
            }
        }
    }

    // 等待所有任务完成
    while tasks.next().await.is_some() {}

    progress.finish_with_message("✅ 弱口令扫描完成");

    // 获取结果
    let final_results = Arc::try_unwrap(results)
        .expect("无法获取最终结果")
        .into_inner();

    let success_count = final_results.iter().filter(|r| r.status == "成功").count();

    // 保存结果
    if args.output && !final_results.is_empty() {
        save_to_excel(
            &final_results,
            &["IP地址", "端口", "服务", "用户名", "密码", "状态", "详情"],
            |r| {
                vec![
                    r.ip.clone(),
                    r.port.to_string(),
                    r.service.clone(),
                    r.username.clone(),
                    r.password.clone(),
                    r.status.clone(),
                    r.details.clone(),
                ]
            },
            "weakpass",
            "weakpass",
        )?;
    }

    // 打印统计
    let elapsed = start.elapsed();
    println!("\n📊 扫描统计:");
    println!("   总任务: {}", total_tasks);
    println!("   发现弱口令: {} 个", success_count);
    println!("   耗时: {:.2?}", elapsed);

    if success_count > 0 {
        println!("\n🔓 弱口令详情:");
        for result in &final_results {
            if result.status == "成功" {
                println!(
                    "   {}:{} [{}] {}:{} - {}",
                    result.ip,
                    result.port,
                    result.service,
                    result.username,
                    result.password,
                    result.details
                );
            }
        }
    }

    Ok(())
}

/// 加载字典文件或解析字符串
/// 如果参数以.txt结尾，则作为字典文件加载
/// 否则作为单个字符串处理（支持逗号分隔多个值）
fn load_dict_or_string(input: &str) -> Result<Vec<String>, Box<dyn Error + Send + Sync>> {
    // 检查是否是.txt文件
    if input.ends_with(".txt") {
        // 作为字典文件处理
        if !Path::new(input).exists() {
            eprintln!("⚠️  字典文件不存在: {}，使用默认字典", input);
            return Ok(get_default_dict(input));
        }

        let content = fs::read_to_string(input)?;
        let dict: Vec<String> = content
            .lines()
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty() && !s.starts_with('#'))
            .collect();

        if dict.is_empty() {
            return Err(format!("字典文件 {} 为空", input).into());
        }

        Ok(dict)
    } else {
        // 作为字符串处理，支持逗号分隔
        let items: Vec<String> = input
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();

        if items.is_empty() {
            return Err("用户名或密码不能为空".into());
        }

        Ok(items)
    }
}

/// 获取默认字典
fn get_default_dict(path: &str) -> Vec<String> {
    if path.contains("username") {
        vec![
            "admin".to_string(),
            "root".to_string(),
            "administrator".to_string(),
            "user".to_string(),
            "test".to_string(),
            "nacos".to_string(),
            "tomcat".to_string(),
        ]
    } else {
        vec![
            "admin".to_string(),
            "password".to_string(),
            "123456".to_string(),
            "admin123".to_string(),
            "root".to_string(),
            "123456789".to_string(),
            "nacos".to_string(),
            "tomcat".to_string(),
            "".to_string(), // 空密码
        ]
    }
}

/// 生成扫描目标列表 (IP, Port, Service)
fn generate_targets(
    ips: &[String],
    service: &str,
) -> Result<Vec<(String, u16, String)>, Box<dyn Error + Send + Sync>> {
    let mut targets = Vec::new();

    for ip in ips {
        match service.to_lowercase().as_str() {
            "ssh" => targets.push((ip.clone(), 22, "SSH".to_string())),
            "rdp" => targets.push((ip.clone(), 3389, "RDP".to_string())),
            "tomcat" => {
                targets.push((ip.clone(), 8080, "Tomcat".to_string()));
                targets.push((ip.clone(), 8009, "Tomcat-AJP".to_string()));
            }
            "nacos" => targets.push((ip.clone(), 8848, "Nacos".to_string())),
            "web" => {
                targets.push((ip.clone(), 80, "HTTP".to_string()));
                targets.push((ip.clone(), 443, "HTTPS".to_string()));
                targets.push((ip.clone(), 8080, "HTTP-Alt".to_string()));
            }
            "all" => {
                targets.push((ip.clone(), 22, "SSH".to_string()));
                targets.push((ip.clone(), 3389, "RDP".to_string()));
                targets.push((ip.clone(), 8080, "Tomcat".to_string()));
                targets.push((ip.clone(), 8848, "Nacos".to_string()));
            }
            _ => return Err(format!("不支持的服务类型: {}", service).into()),
        }
    }

    Ok(targets)
}

/// 扫描单个凭证
async fn scan_credential(
    ip: &str,
    port: u16,
    service: &str,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    match service {
        "SSH" => check_ssh(ip, port, username, password, timeout).await,
        "RDP" => check_rdp(ip, port, username, password, timeout).await,
        "Tomcat" => check_tomcat(ip, port, username, password, timeout).await,
        "Nacos" => check_nacos(ip, port, username, password, timeout).await,
        "HTTP" | "HTTPS" | "HTTP-Alt" => {
            check_web_common(ip, port, username, password, timeout, service).await
        }
        _ => None,
    }
}

/// SSH 弱口令检测
async fn check_ssh(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    let addr = format!("{}:{}", ip, port);
    let username_clone = username.to_string();
    let password_clone = password.to_string();
    let ip_clone = ip.to_string();

    // 使用 tokio::task::spawn_blocking 在阻塞线程中执行 SSH 连接
    let result = tokio::task::spawn_blocking(move || {
        let tcp =
            TcpStream::connect_timeout(&addr.parse().ok()?, Duration::from_secs(timeout)).ok()?;
        tcp.set_read_timeout(Some(Duration::from_secs(timeout)))
            .ok()?;
        tcp.set_write_timeout(Some(Duration::from_secs(timeout)))
            .ok()?;

        let mut session = Session::new().ok()?;
        session.set_tcp_stream(tcp);
        session.set_timeout((timeout * 1000) as u32);
        session.handshake().ok()?;

        // 尝试密码认证
        if session
            .userauth_password(&username_clone, &password_clone)
            .is_ok()
            && session.authenticated()
        {
            return Some(());
        }
        None
    })
    .await
    .ok()?;

    if result.is_some() {
        Some(WeakPassResult::success(
            ip_clone,
            port,
            "SSH".to_string(),
            username.to_string(),
            password.to_string(),
            "SSH认证成功".to_string(),
        ))
    } else {
        None
    }
}

/// RDP 弱口令检测（基础端口探测）
async fn check_rdp(
    ip: &str,
    port: u16,
    _username: &str,
    _password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    // 注意：完整的 RDP 认证需要复杂的协议实现
    // 这里仅做端口连通性检测作为示例
    let addr = format!("{}:{}", ip, port);

    match tokio::time::timeout(
        Duration::from_secs(timeout),
        tokio::net::TcpStream::connect(&addr),
    )
    .await
    {
        Ok(Ok(_stream)) => {
            // RDP 端口开放，但实际认证需要 RDP 协议库
            // 这里只标记端口开放，实际项目中应集成 RDP 认证库
            None
        }
        _ => None,
    }
}

/// Tomcat Manager 弱口令检测
async fn check_tomcat(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    let urls = vec![
        format!("http://{}:{}/manager/html", ip, port),
        format!("http://{}:{}/manager/text", ip, port),
        format!("http://{}:{}/host-manager/html", ip, port),
    ];

    let client = HttpClient::builder()
        .timeout(Duration::from_secs(timeout))
        .danger_accept_invalid_certs(true)
        .build()
        .ok()?;

    for url in urls {
        let response = client
            .get(&url)
            .basic_auth(username, Some(password))
            .send()
            .await
            .ok()?;

        if response.status().is_success() {
            let body = response.text().await.ok()?;
            if body.contains("Tomcat") || body.contains("Manager") {
                return Some(WeakPassResult::success(
                    ip.to_string(),
                    port,
                    "Tomcat".to_string(),
                    username.to_string(),
                    password.to_string(),
                    format!("Tomcat Manager 访问成功: {}", url),
                ));
            }
        }
    }

    None
}

/// Nacos 弱口令检测
async fn check_nacos(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
) -> Option<WeakPassResult> {
    let login_url = format!("http://{}:{}/nacos/v1/auth/login", ip, port);

    let client = HttpClient::builder()
        .timeout(Duration::from_secs(timeout))
        .danger_accept_invalid_certs(true)
        .build()
        .ok()?;

    let params = [("username", username), ("password", password)];

    let response = client.post(&login_url).form(&params).send().await.ok()?;

    if response.status().is_success() {
        let body = response.text().await.ok()?;
        if body.contains("accessToken") || body.contains("tokenTtl") {
            return Some(WeakPassResult::success(
                ip.to_string(),
                port,
                "Nacos".to_string(),
                username.to_string(),
                password.to_string(),
                "Nacos 登录成功".to_string(),
            ));
        }
    }

    None
}

/// 通用 Web 应用弱口令检测
async fn check_web_common(
    ip: &str,
    port: u16,
    username: &str,
    password: &str,
    timeout: u64,
    service: &str,
) -> Option<WeakPassResult> {
    // 常见的登录路径
    let login_paths = vec![
        "/login",
        "/admin",
        "/admin/login",
        "/user/login",
        "/auth/login",
        "/api/login",
        "/console",
        "/manage",
    ];

    let protocol = if port == 443 { "https" } else { "http" };

    let client = HttpClient::builder()
        .timeout(Duration::from_secs(timeout))
        .danger_accept_invalid_certs(true)
        .redirect(reqwest::redirect::Policy::limited(3))
        .build()
        .ok()?;

    for path in login_paths {
        let url = format!("{}://{}:{}{}", protocol, ip, port, path);

        // 尝试 HTTP Basic Auth
        if let Ok(response) = client
            .get(&url)
            .basic_auth(username, Some(password))
            .send()
            .await
        {
            if response.status().is_success() {
                return Some(WeakPassResult::success(
                    ip.to_string(),
                    port,
                    service.to_string(),
                    username.to_string(),
                    password.to_string(),
                    format!("Basic Auth 成功: {}", url),
                ));
            }
        }

        // 尝试 POST 表单登录
        let post_data = [
            ("username", username),
            ("password", password),
            ("user", username),
            ("pass", password),
        ];

        if let Ok(response) = client.post(&url).form(&post_data).send().await {
            let body = response.text().await.ok()?;
            // 检查登录成功的常见标识
            if body.contains("success")
                || body.contains("dashboard")
                || body.contains("welcome")
                || (body.contains("token") && !body.contains("error"))
            {
                return Some(WeakPassResult::success(
                    ip.to_string(),
                    port,
                    service.to_string(),
                    username.to_string(),
                    password.to_string(),
                    format!("表单登录成功: {}", url),
                ));
            }
        }
    }

    None
}
