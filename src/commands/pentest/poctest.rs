use clap::Args;
use serde::Deserialize;
use std::error::Error;
use std::fs;
use std::net::ToSocketAddrs;
use std::path::Path;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::time::{timeout, Duration};

#[derive(Args, Debug)]
pub struct PocTest {
    /// ç›®æ ‡IPåœ°å€æˆ–åŸŸå
    #[arg(short, long)]
    pub target: String,


    /// æ’ä»¶è·¯å¾„ï¼ˆæ”¯æŒæ–‡ä»¶å¤¹æˆ–å•ä¸ªYAMLæ–‡ä»¶ï¼‰
    #[arg(long, default_value = "./plugins")]
    pub plugin: String,

    /// è¾“å‡ºè¯¦ç»†ä¿¡æ¯
    #[arg(short, long, default_value = "false")]
    pub verbose: bool,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "lowercase", tag = "type")]
pub enum Plugin {
    Http {
        id: String,
        name: String,
        #[serde(default)]
        port: u16,
        #[serde(rename = "match")]
        match_: HttpMatch,
    },
    Tcp {
        id: String,
        name: String,
        #[serde(default)]
        port: u16,
        payload: String,
        #[serde(rename = "match")]
        match_: TcpMatch,
    },
    Ms17010 {
        id: String,
        name: String,
        port: u16,
        #[serde(rename = "match")]
        match_: MS17010Match,
    },
}

#[derive(Debug, Deserialize, Clone)]
pub struct MS17010Match {
    #[serde(rename = "contains_hex")]
    pub contains_hex: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct HttpMatch {
    pub path: String,
    #[serde(default = "default_method")]
    pub method: String,
    #[serde(default)]
    pub status: Option<u16>,
    #[serde(default)]
    pub contains: Option<String>,
}

fn default_method() -> String {
    "GET".to_string()
}

#[derive(Debug, Deserialize, Clone)]
pub struct TcpMatch {
    #[serde(default)]
    pub contains_hex: Option<String>,
}

pub async fn run(args: &PocTest) -> Result<(), Box<dyn Error + Send + Sync>> {
    let plugins = load_plugins(&args.plugin)?;

    println!(
        "ğŸ” å¼€å§‹æ£€æµ‹ç›®æ ‡ï¼š{}",
        args.target,
    );

    for plugin in plugins {
        match plugin {
            Plugin::Http {
                id,
                name,
                port,
                match_: m,
            } => {
                if let Some(msg) = test_http(&args.target, port, &m).await {
                    println!("âœ… å‘½ä¸­æ’ä»¶ï¼š{} [{}] - {}", name, id, msg);
                } else if args.verbose {
                    println!("âŒ æœªå‘½ä¸­æ’ä»¶ï¼š{} [{}]", name, id);
                }
            }

            Plugin::Tcp {
                id,
                name,
                port,
                payload,
                match_: m,
            } => {

                if let Some(msg) = test_tcp(&args.target, port, &payload, &m).await {
                    println!("âœ… å‘½ä¸­æ’ä»¶ï¼š{} [{}] - {}", name, id, msg);
                } else if args.verbose {
                    println!("âŒ æœªå‘½ä¸­æ’ä»¶ï¼š{} [{}]", name, id);
                }
            }
            Plugin::Ms17010 {
                id,
                name,
                port,
                match_:_,
            }=>{
                match test_ms17_010(&args.target, port).await {
                    Ok(true) => println!("âœ… å‘½ä¸­æ’ä»¶ï¼š{} [{}] - å­˜åœ¨ MS17-010 æ¼æ´", name, id),
                    Ok(false) => println!("âŒ æœªå‘½ä¸­æ’ä»¶ï¼š{} [{}]", name, id),
                    Err(e) => println!("âš ï¸ æ’ä»¶ {} [{}] æ‰§è¡Œå¤±è´¥: {}", name, id, e),
                }
            }
        }
    }

    Ok(())
}

fn load_plugins<P: AsRef<Path>>(path: P) -> Result<Vec<Plugin>, Box<dyn Error + Send + Sync>> {
    let path = path.as_ref();
    let mut plugins = Vec::new();

    if path.is_dir() {
        for entry in fs::read_dir(path)? {
            let entry = entry?;
            if entry.path().extension().map_or(false, |e| e == "yaml") {
                let content = fs::read_to_string(entry.path())?;
                let plugin: Plugin = serde_yaml::from_str(&content)?;
                plugins.push(plugin);
            }
        }
    } else if path.is_file() {
        let content = fs::read_to_string(path)?;
        let plugin: Plugin = serde_yaml::from_str(&content)?;
        plugins.push(plugin);
    }

    Ok(plugins)
}

async fn test_http(
    ip: &str,
    port: u16,
    m: &HttpMatch,
) -> Option<String> {
    let url = format!("http://{}:{}{}", ip, port, m.path);
    let client = reqwest::Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(5))
        .build()
        .ok()?;

    let resp = match m.method.to_uppercase().as_str() {
        "POST" => client.post(&url).send().await.ok()?,
        _ => client.get(&url).send().await.ok()?,
    };

    let status_match = m.status.map_or(true, |s| s == resp.status().as_u16());
    let body = resp.text().await.ok()?;

    let body_match = m.contains.as_ref().map_or(true, |s| body.contains(s));

    if status_match && body_match {
        Some("çŠ¶æ€ç ä¸å†…å®¹åŒ¹é…".to_string())
    } else {
        None
    }
}

async fn test_tcp(
    ip: &str,
    port: u16,
    payload_hex: &str,
    m: &TcpMatch,
) -> Option<String> {
    let addr = format!("{}:{}", ip, port);
    let mut addrs_iter = addr.to_socket_addrs().ok()?;
    let socket = addrs_iter.next()?;

    let stream_result = timeout(Duration::from_secs(3), TcpStream::connect(socket)).await;
    let mut stream = match stream_result {
        Ok(Ok(s)) => s,
        _ => return None,
    };

    let payload = hex_string_to_bytes(payload_hex).ok()?;
    if timeout(Duration::from_secs(3), stream.write_all(&payload)).await.ok().is_none() {
        return None;
    }

    let mut buf = vec![0u8; 4096];
    let n = match timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        Ok(Ok(n)) => n,
        _ => return None,
    };

    let resp = &buf[..n];

    if let Some(expect_hex) = &m.contains_hex {
        let expected = hex_string_to_bytes(expect_hex).ok()?;
        if resp.windows(expected.len()).any(|w| w == expected.as_slice()) {
            return Some("å“åº”åŒ…å«åŒ¹é…å­—èŠ‚åºåˆ—".to_string());
        }
    }

    None
}

pub async fn test_ms17_010(ip: &str, port: u16) -> Result<bool, Box<dyn std::error::Error>> {

    fn hex_string_to_bytes(hex: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let hex = hex.replace([' ', '\n'], "");
        if hex.len() % 2 != 0 {
            return Err("åå…­è¿›åˆ¶å­—ç¬¦ä¸²é•¿åº¦ä¸åˆæ³•".into());
        }
        (0..hex.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).map_err(|e| e.into()))
            .collect()
    }

    let addr = format!("{}:{}", ip, port);
    let mut addrs_iter = addr.to_socket_addrs()?.into_iter();
    let socket = addrs_iter.next().ok_or("æ— æ•ˆåœ°å€")?;
    let mut stream = timeout(Duration::from_secs(5), TcpStream::connect(socket)).await??;

    // ---------- 1. Negotiate Protocol Request ----------
    let negotiate = hex_string_to_bytes(
        "00000054ff534d427200000000180100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )?;

    stream.write_all(&negotiate).await?;

    let mut buf = vec![0u8; 4096];
    let _ = timeout(Duration::from_secs(3), stream.read(&mut buf)).await??;

    // ---------- 2. Session Setup Request ----------
    let session_setup = hex_string_to_bytes(
        "000000a4ff534d4273000000001801c80000000000000000000000000000000000000000000000000dff000000000000004800000000000000000000000000000000ffff0000"
    )?;

    stream.write_all(&session_setup).await?;

    let mut session_buf = vec![0u8; 4096];
    let _ = timeout(Duration::from_secs(3), stream.read(&mut session_buf)).await??;

    let uid = session_buf.get(32).copied().unwrap_or(0);
    if uid == 0 {
        return Err("æ— æ³•ä» Session Setup å“åº”ä¸­æå– UID".into());
    }

    // ---------- 3. Tree Connect Request ----------
    let ipc = format!(r"\\{}\\IPC$", ip);
    let ipc_utf16: Vec<u8> = ipc.encode_utf16().flat_map(|c| c.to_le_bytes()).collect();

    let tree_connect_prefix = hex_string_to_bytes(
        "0000004fff534d4275000000001801c800000000000000000000000000000000
         000000000000000004ff000000000c00"
    )?;

    let tree_connect = [&tree_connect_prefix[..], &ipc_utf16[..], &[0x00, 0x00]].concat();
    stream.write_all(&tree_connect).await?;

    let mut tree_buf = vec![0u8; 4096];
    let _ = timeout(Duration::from_secs(3), stream.read(&mut tree_buf)).await??;

    let tid = tree_buf.get(28).copied().unwrap_or(0);
    if tid == 0 {
        return Err("æ— æ³•ä» Tree Connect å“åº”ä¸­æå– TID".into());
    }

    // ---------- 4. PeekNamedPipe Request ----------
    let mut peek = hex_string_to_bytes(
        "0000004aff534d422500000
         00000000000000000000000010000000
         000000000000000000000000"
    )?;

    peek[28] = tid; // TID
    peek[32] = uid; // UID

    stream.write_all(&peek).await?;

    let mut peek_buf = vec![0u8; 4096];
    let _ = timeout(Duration::from_secs(3), stream.read(&mut peek_buf)).await??;

    // ---------- æ¼æ´ç‰¹å¾åŒ¹é… ----------
    let signature = [0x05, 0x02, 0x00, 0xc0];
    if peek_buf.windows(4).any(|w| w == signature) {
        return Ok(true);
    }

    Ok(false)
}

fn hex_string_to_bytes(hex: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    let hex = hex.replace(|c: char| c.is_whitespace(), "");
    if hex.len() % 2 != 0 {
        return Err("Hex string é•¿åº¦ä¸æ˜¯å¶æ•°".into());
    }

    (0..hex.len())
        .step_by(2)
        .map(|i| {
            u8::from_str_radix(&hex[i..i + 2], 16)
                .map_err(|e| format!("è§£æ hex å¤±è´¥: {}", e).into())
        })
        .collect()
}
