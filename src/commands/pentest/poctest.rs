use clap::Args;
use serde::Deserialize;
use std::error::Error;
use std::fs;
use std::net::ToSocketAddrs;
use std::path::Path;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio::time::{Duration, timeout};

#[derive(Args, Debug)]
pub struct PocTest {
    /// ç›®æ ‡IPåœ°å€æˆ–åŸŸå
    #[arg(short, long)]
    pub target: String,

    /// æ’ä»¶è·¯å¾„ï¼ˆæ”¯æŒæ–‡ä»¶å¤¹æˆ–å•ä¸ªYAMLæ–‡ä»¶ï¼‰
    #[arg(long, default_value = "./plugins")]
    pub plugin: String,

    /// è¾“å‡ºè¯¦ç»†ä¿¡æ¯
    #[arg(short, long, default_value = "false")]
    pub verbose: bool,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "lowercase", tag = "type")]
pub enum Plugin {
    Http {
        id: String,
        name: String,
        #[serde(default)]
        port: u16,
        #[serde(rename = "match")]
        match_: HttpMatch,
    },
    Tcp {
        id: String,
        name: String,
        #[serde(default)]
        port: u16,
        payload: String,
        #[serde(rename = "match")]
        match_: TcpMatch,
    },
    Ms17010 {
        id: String,
        name: String,
        port: u16,
        #[serde(rename = "match")]
        match_: MS17010Match,
    },
}

#[derive(Debug, Deserialize, Clone)]
pub struct MS17010Match {
    #[serde(rename = "contains_hex")]
    pub contains_hex: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct HttpMatch {
    pub path: String,
    #[serde(default = "default_method")]
    pub method: String,
    #[serde(default)]
    pub status: Option<u16>,
    #[serde(default)]
    pub contains: Option<String>,
}

fn default_method() -> String {
    "GET".to_string()
}

#[derive(Debug, Deserialize, Clone)]
pub struct TcpMatch {
    #[serde(default)]
    pub contains_hex: Option<String>,
}

pub async fn run(args: &PocTest) -> Result<(), Box<dyn Error + Send + Sync>> {
    let plugins = load_plugins(&args.plugin)?;

    println!("ğŸ” å¼€å§‹æ£€æµ‹ç›®æ ‡ï¼š{}", args.target,);

    for plugin in plugins {
        match plugin {
            Plugin::Http {
                id,
                name,
                port,
                match_: m,
            } => {
                if let Some(msg) = test_http(&args.target, port, &m).await {
                    println!("âœ… å‘½ä¸­æ’ä»¶ï¼š{} [{}] - {}", name, id, msg);
                } else if args.verbose {
                    println!("âŒ æœªå‘½ä¸­æ’ä»¶ï¼š{} [{}]", name, id);
                }
            }

            Plugin::Tcp {
                id,
                name,
                port,
                payload,
                match_: m,
            } => {
                if let Some(msg) = test_tcp(&args.target, port, &payload, &m).await {
                    println!("âœ… å‘½ä¸­æ’ä»¶ï¼š{} [{}] - {}", name, id, msg);
                } else if args.verbose {
                    println!("âŒ æœªå‘½ä¸­æ’ä»¶ï¼š{} [{}]", name, id);
                }
            }
            Plugin::Ms17010 {
                id,
                name,
                port,
                match_: _,
            } => match test_ms17_010(&args.target, port).await {
                Ok(true) => println!("âœ… å‘½ä¸­æ’ä»¶ï¼š{} [{}] - å­˜åœ¨ MS17-010 æ¼æ´", name, id),
                Ok(false) => println!("âŒ æœªå‘½ä¸­æ’ä»¶ï¼š{} [{}]", name, id),
                Err(e) => println!("âš ï¸ æ’ä»¶ {} [{}] æ‰§è¡Œå¤±è´¥: {}", name, id, e),
            },
        }
    }

    Ok(())
}

fn load_plugins<P: AsRef<Path>>(path: P) -> Result<Vec<Plugin>, Box<dyn Error + Send + Sync>> {
    let path = path.as_ref();
    let mut plugins = Vec::new();

    if path.is_dir() {
        for entry in fs::read_dir(path)? {
            let entry = entry?;
            if entry.path().extension().map_or(false, |e| e == "yaml") {
                let content = fs::read_to_string(entry.path())?;
                let plugin: Plugin = serde_yaml::from_str(&content)?;
                plugins.push(plugin);
            }
        }
    } else if path.is_file() {
        let content = fs::read_to_string(path)?;
        let plugin: Plugin = serde_yaml::from_str(&content)?;
        plugins.push(plugin);
    }

    Ok(plugins)
}

async fn test_http(ip: &str, port: u16, m: &HttpMatch) -> Option<String> {
    let url = format!("http://{}:{}{}", ip, port, m.path);
    let client = reqwest::Client::builder()
        .danger_accept_invalid_certs(true)
        .timeout(Duration::from_secs(5))
        .build()
        .ok()?;

    let resp = match m.method.to_uppercase().as_str() {
        "POST" => client.post(&url).send().await.ok()?,
        _ => client.get(&url).send().await.ok()?,
    };

    let status_match = m.status.map_or(true, |s| s == resp.status().as_u16());
    let body = resp.text().await.ok()?;

    let body_match = m.contains.as_ref().map_or(true, |s| body.contains(s));

    if status_match && body_match {
        Some("çŠ¶æ€ç ä¸å†…å®¹åŒ¹é…".to_string())
    } else {
        None
    }
}

async fn test_tcp(ip: &str, port: u16, payload_hex: &str, m: &TcpMatch) -> Option<String> {
    let addr = format!("{}:{}", ip, port);
    let mut addrs_iter = addr.to_socket_addrs().ok()?;
    let socket = addrs_iter.next()?;

    let stream_result = timeout(Duration::from_secs(3), TcpStream::connect(socket)).await;
    let mut stream = match stream_result {
        Ok(Ok(s)) => s,
        _ => return None,
    };

    let payload = hex_string_to_bytes(payload_hex).ok()?;
    if timeout(Duration::from_secs(3), stream.write_all(&payload))
        .await
        .ok()
        .is_none()
    {
        return None;
    }

    let mut buf = vec![0u8; 4096];
    let n = match timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        Ok(Ok(n)) => n,
        _ => return None,
    };

    let resp = &buf[..n];

    if let Some(expect_hex) = &m.contains_hex {
        let expected = hex_string_to_bytes(expect_hex).ok()?;
        if resp
            .windows(expected.len())
            .any(|w| w == expected.as_slice())
        {
            return Some("å“åº”åŒ…å«åŒ¹é…å­—èŠ‚åºåˆ—".to_string());
        }
    }

    None
}

fn hex_string_to_bytes(hex: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    let hex = hex.replace(&[' ', '\n', '\t'][..], "");
    if hex.len() % 2 != 0 {
        return Err("åå…­è¿›åˆ¶å­—ç¬¦ä¸²é•¿åº¦ä¸åˆæ³•".into());
    }
    Ok((0..hex.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).unwrap())
        .collect())
}

pub async fn test_ms17_010(target_ip: &str, port: u16) -> Result<bool, Box<dyn std::error::Error>> {
    let mut stream = TcpStream::connect((target_ip, port)).await?;

    // 1. å‘é€ Negotiate Protocol Request
    let negotiate = hex_string_to_bytes(
        "00000054ff534d427200000000180128000000000000000000000000000004920000900d003100024c414e4d414e312e3000024c4d312e325830303200024e54204c414e4d414e20312e3000024e54204c4d20302e313200",
    )?; // éœ€è¦è¡¥å……å®Œæ•´æŠ¥æ–‡
    stream.write_all(&negotiate).await?;

    // æ¥æ”¶å“åº”
    let mut buf = [0u8; 1024];
    let n = timeout(Duration::from_secs(3), stream.read(&mut buf)).await??;
    let _negotiate_resp = &buf[..n];

    // 2. å‘é€ Session Setup è¯·æ±‚
    let session_setup = hex_string_to_bytes(
        "00000090ff534d427300000000180128000000000000000000000000000004920000900d0cff000000dfff0200010000000000320000000000d400008055004e544c4d5353500001000000050208a2010001002000000010001000220000002e007457754c43473171475769334a31456e57696e646f7773203230303020323139350057696e646f7773203230303020352e3000",
    )?; // éœ€è¦è¡¥å……å®Œæ•´æŠ¥æ–‡
    stream.write_all(&session_setup).await?;

    // æ¥æ”¶å“åº”
    let mut buf = [0u8; 1024];
    let n = timeout(Duration::from_secs(3), stream.read(&mut buf)).await??;
    let _negotiate_resp = &buf[..n];

    // 3. å‘é€ Session Setup è¯·æ±‚
    let session_setup = hex_string_to_bytes(
        "000000c2ff534d427300000000180128000000000000000000000000000004920008900d0cff000000dfff02000100000000006400000000005cd0008087004e544c4d5353500003000000010001004000000000000000420000000200020042000000000000004400000020002000440000000000000064000000050208a200002e007400570075004c00430047003100710047005700690033004a00310045006e0057696e646f7773203230303020323139350057696e646f7773203230303020352e3000",
    )?; // éœ€è¦è¡¥å……å®Œæ•´æŠ¥æ–‡
    stream.write_all(&session_setup).await?;

    // æ¥æ”¶ Session Setup å“åº”
    let n = timeout(Duration::from_secs(3), stream.read(&mut buf)).await??;
    let session_buf = &buf[..n];
    if session_buf.len() < 34 {
        return Err("Session å“åº”å¤ªçŸ­ï¼Œæ— æ³•æå– UID".into());
    }

    // 4. å‘é€ Tree Connect è¯·æ±‚
    let ipc = format!("\\\\{}\\IPC$", target_ip);
    let ipc_encoded: Vec<u8> = ipc.encode_utf16().flat_map(|c| c.to_le_bytes()).collect();

    let hex_str: String = ipc_encoded
        .chunks(2)
        .filter_map(|chunk| chunk.get(0)) // å–ä½ä½å­—èŠ‚
        .map(|b| format!("{:02x}", b))
        .collect::<Vec<String>>()
        .join("");
    let poc_hex = format!(
        "000000{}ff534d427500000000180128000000000000000000000000000004920008900d04ff00000000000100{}0000{}003f3f3f3f3f00",
        format!("{:x}", (hex_str.len() + 102)/2).to_string(),
        format!("{:x}", hex_str.len()/2 + 8).to_string(),
        hex_str
    );
    let tree_connect = hex_string_to_bytes(&poc_hex)?; // Tree Connect è¯·æ±‚å­—èŠ‚æµ

    stream.write_all(&tree_connect).await?;
    let n = timeout(Duration::from_secs(3), stream.read(&mut buf)).await??;
    let tree_buf = &buf[..n];
    if tree_buf.len() < 30 {
        return Err("Tree Connect å“åº”å¤ªçŸ­".into());
    }

    // 4. å‘é€ PeekNamedPipe è¯·æ±‚
    let peek_named_pipe = hex_string_to_bytes(
        "0000004aff534d422500000000180128000000000000000000000000000804920008900d1000000000ffffffff0000000000000000000000004a0000004a0002002300000007005c504950455c00",
    )?; // PeekNamedPipe è¯·æ±‚å­—èŠ‚æµ

    stream.write_all(&peek_named_pipe).await?;
    let n = timeout(Duration::from_secs(3), stream.read(&mut buf)).await??;
    let peek_buf = &buf[..n];

    // æ£€æŸ¥ MS17-010 ç‰¹å¾
    let signature = [0x05, 0x02, 0x00, 0xc0];
    let is_vulnerable = peek_buf.windows(4).any(|window| window == signature);

    Ok(is_vulnerable)
}
