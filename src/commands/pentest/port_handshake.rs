// src/commands/pentest/port_handshake.rs
use crate::commands::pentest::fingerprint::Fingerprint;
use native_tls::TlsConnector as NativeTlsConnector;
use std::time::{Duration, Instant};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;
use tokio_native_tls::TlsConnector;

/// connect + multi-read 工具：建立 TCP 连接（带超时），然后做多次短读直到达到总超时或读满。
pub async fn connect_and_read(
    addr: &str,
    connect_timeout: Duration,
    total_read_timeout: Duration,
    per_read: Duration,
    max_bytes: usize,
) -> Option<Vec<u8>> {
    let stream = match tokio::time::timeout(connect_timeout, TcpStream::connect(addr)).await {
        Ok(Ok(s)) => s,
        _ => return None,
    };

    let mut stream = stream;
    let start = Instant::now();
    let mut out: Vec<u8> = Vec::new();

    while start.elapsed() < total_read_timeout && out.len() < max_bytes {
        let mut buf = vec![0u8; 1024.min(max_bytes - out.len())];
        match tokio::time::timeout(per_read, stream.read(&mut buf)).await {
            Ok(Ok(0)) => break,
            Ok(Ok(n)) => {
                out.extend_from_slice(&buf[..n]);
                if out.starts_with(b"SSH-") || out.starts_with(b"HTTP/") || out.len() >= 1024 {
                    break;
                }
            }
            _ => {
                // 单次 read 超时或失败，继续循环（避免 sleep 以降低总延时）
            }
        }
    }

    if out.is_empty() { None } else { Some(out) }
}

/// 提取 banner 文本（兼容 HTTP、MySQL、RDP、常规 ASCII 等）
pub fn extract_banner_text(buf: &[u8]) -> String {
    if is_mysql_handshake(buf) {
        return extract_mysql_banner(buf);
    } else if is_rdp_response(buf) {
        return extract_rdp_banner(buf);
    }

    if let Ok(text) = std::str::from_utf8(buf) {
        if text.starts_with("HTTP/") {
            let mut status_line = None;
            let mut server_line = None;

            for line in text.lines() {
                if status_line.is_none() && line.starts_with("HTTP/") {
                    status_line = Some(line.trim());
                } else if line.to_ascii_lowercase().starts_with("server:") {
                    server_line = Some(line.trim());
                }
                if status_line.is_some() && server_line.is_some() {
                    break;
                }
            }

            return match (status_line, server_line) {
                (Some(status), Some(server)) => format!("{} | {}", status, server),
                (Some(status), None) => status.to_string(),
                _ => "HTTP Response".to_string(),
            };
        }
    }

    match std::str::from_utf8(buf) {
        Ok(s) => s.trim().to_string(),
        Err(_) => buf
            .iter()
            .filter(|&&b| (b.is_ascii_graphic() || b == b' '))
            .map(|&b| b as char)
            .collect::<String>(),
    }
}

/// =======================
/// MySQL
pub fn is_mysql_handshake(buf: &[u8]) -> bool {
    if buf.len() < 5 {
        return false;
    }
    if buf.get(4) == Some(&0x0A) {
        return true;
    }
    if let Ok(s) = std::str::from_utf8(buf) {
        let s_lower = s.to_ascii_lowercase();
        if s_lower.contains("mysql") || s_lower.contains("auth_plugin") {
            return true;
        }
    }
    false
}

pub fn extract_mysql_banner(buf: &[u8]) -> String {
    let mut banner = String::new();
    if let Some(end) = buf.get(5..).and_then(|s| s.iter().position(|&b| b == 0)) {
        let version = &buf[5..5 + end];
        if let Ok(version_str) = std::str::from_utf8(version) {
            banner.push_str("MySQL ");
            banner.push_str(version_str);
        }
    }
    if banner.is_empty() {
        // fallback: printable extraction
        banner = extract_banner_text(buf);
    }
    banner
}

/// =======================
/// RDP
pub fn is_rdp_response(buf: &[u8]) -> bool {
    if buf.len() < 7 {
        return false;
    }
    if buf[0] != 0x03 || buf[1] != 0x00 {
        return false;
    }
    let b5 = buf[5];
    b5 == 0xD0 || b5 == 0xE0 || b5 == 0x80 || b5 == 0x02
}

pub fn extract_rdp_banner(_buf: &[u8]) -> String {
    "RDP Protocol Detected".to_string()
}

pub async fn send_rdp_probe(stream: &mut TcpStream) -> Option<String> {
    const RDP_NEGOTIATION_REQUEST: &[u8] = &[
        0x03, 0x00, 0x00, 0x13, 0x0e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x00,
    ];

    if stream.write_all(RDP_NEGOTIATION_REQUEST).await.is_err() {
        return None;
    }
    let mut buf = [0u8; 512];
    let n = match tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        Ok(Ok(n)) => n,
        _ => return None,
    };
    if n >= 7 && is_rdp_response(&buf[..n]) {
        return Some("RDP".to_string());
    }
    None
}

/// =======================
/// HTTP / Middleware 探测（含 TLS 尝试）
// 请用此实现替换原有的 try_http_probe_with_tls 函数体（签名保持不变）
pub async fn try_http_probe_with_tls(
    mut stream: TcpStream,
    ip: &str,
    port: u16,
    buf_size: usize,
) -> Option<(String, Vec<String>)> {
    let url = if port == 443 {
        format!("https://{}", ip)
    } else {
        format!("http://{}:{}", ip, port)
    };

    // 1) 直接 GET
    let req = format!(
        "GET / HTTP/1.1\r\nHost: {}\r\nUser-Agent: gxtools/0.1\r\nConnection: close\r\n\r\n",
        ip
    );
    let _ = stream.write_all(req.as_bytes()).await;

    if let Some(resp) = read_full_response(&mut stream, buf_size, Duration::from_secs(3)).await {
        let parsed = parse_http_response(&resp);
        let mut evidence = vec!["http-get".to_string()];

        if let Some(ref srv) = parsed.server {
            evidence.push(format!("server:{}", srv));
        }
        if let Some(ref title) = parsed.title {
            evidence.push(format!("title:{}", title));
        }

        // 统一格式化输出
        let mut banner_line = format!("{} ", url);
        if let Some(ref t) = parsed.title {
            banner_line.push_str(&format!("「{}」 ", t));
        }
        if let Some(ref s) = parsed.server {
            banner_line.push_str(&format!("「{}」 ", s));
        }
        if let Some(ref st) = parsed.status {
            banner_line.push_str(&format!("「{}」 ", st));
        }
        if let Some(ref ct) = parsed.content_type {
            banner_line.push_str(&format!("「{}」", ct));
        }

        return Some((normalize_banner(&banner_line), evidence));
    }

    None
}




/// 简单从 HTTP 响应头/Body 识别中间件/应用（nginx/tomcat/nacos/spring-boot/hadoop/apache等）
pub fn detect_middleware_from_http(resp: &str) -> Option<String> {
    let lower = resp.to_ascii_lowercase();
    // Server header quick checks
    if let Some(srv) = extract_server_header(resp) {
        let sl = srv.to_ascii_lowercase();
        if sl.contains("nginx") {
            return Some("nginx".to_string());
        } else if sl.contains("tomcat") || sl.contains("jakarta") {
            return Some("tomcat".to_string());
        } else if sl.contains("apache") || sl.contains("httpd") {
            return Some("apache".to_string());
        } else if sl.contains("jetty") {
            return Some("jetty".to_string());
        }
    }
    // body heuristics
    if lower.contains("apache tomcat") || lower.contains("tomcat") {
        return Some("tomcat".to_string());
    }
    if lower.contains("spring boot")
        || lower.contains("whitelabel error page")
        || lower.contains("springframework")
    {
        return Some("spring-boot".to_string());
    }
    if lower.contains("nacos") || lower.contains("nacos") {
        return Some("nacos".to_string());
    }
    if lower.contains("hadoop") || lower.contains("yarn") || lower.contains("namenode") {
        return Some("hadoop".to_string());
    }
    if lower.contains("nginx") {
        return Some("nginx".to_string());
    }
    None
}

pub fn extract_server_header(resp: &str) -> Option<String> {
    for line in resp.lines() {
        if line.to_ascii_lowercase().starts_with("server:") {
            return Some(line.splitn(2, ':').nth(1).unwrap_or("").trim().to_string());
        }
    }
    None
}

/// probe_http_services_connect 使用指纹库（如有）并回退到 detect_middleware_from_http
pub async fn probe_http_services_connect(
    ip: &str,
    port: u16,
    fingerprints: &[Fingerprint],
) -> Option<(String, Vec<String>)> {
    let addr = format!("{}:{}", ip, port);
    // connect with timeout
    let stream = match tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(&addr)).await {
        Ok(Ok(s)) => s,
        _ => return None,
    };

    // 优先尝试 TLS/HTTP probe that returns response + evidence
    if let Some((banner, mut evidence)) = try_http_probe_with_tls(stream, ip, port, 4096).await {
        // first try match against fingerprints (if present)
        let lc = banner.to_ascii_lowercase();
        for fp in fingerprints {
            if !fp.ports.is_empty() && !fp.ports.contains(&port) {
                continue;
            }
            for probe in &fp.probes {
                // simple substring match across banner and evidence strings
                let mut all_match = true;
                for kw in &probe.match_headers {
                    if !lc.contains(&kw.to_lowercase()) {
                        all_match = false;
                        break;
                    }
                }
                for kw in &probe.match_body {
                    if !lc.contains(&kw.to_lowercase()) {
                        all_match = false;
                        break;
                    }
                }
                if all_match {
                    evidence.push(format!("fingerprint:{}", fp.name));
                    return Some((fp.name.clone(), evidence));
                }
            }
        }

        // fallback to middleware heuristics using evidence or banner
        for e in &evidence {
            if e.starts_with("middleware:") {
                return Some((
                    e.splitn(2, ':').nth(1).unwrap_or("").to_string(),
                    evidence,
                ));
            }
            if e.starts_with("server:") {
                return Some((
                    format!("HTTP ({})", e.splitn(2, ':').nth(1).unwrap_or("")),
                    evidence,
                ));
            }
        }

        if let Some(mw) = detect_middleware_from_http(&banner) {
            evidence.push(format!("middleware:{}", mw));
            return Some((mw, evidence));
        }

        if !banner.is_empty() {
            return Some((banner, evidence));
        }
    }

    None
}


/// =======================
/// PostgreSQL - 使用 SSLRequest 探测 (8 字节)
/// 请求: int32(8) + int32(80877103)
/// 服务器返回单字节 'S' 表示支持 SSL, 'N' 表示不支持, 或返回错误（仍表示 PostgreSQL）。
pub async fn probe_postgres(addr: &str) -> Option<String> {
    let mut stream =
        match tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(addr)).await {
            Ok(Ok(s)) => s,
            _ => return None,
        };

    // SSLRequest payload
    let mut req = Vec::new();
    req.extend_from_slice(&8u32.to_be_bytes()); // length
    req.extend_from_slice(&80877103u32.to_be_bytes()); // SSLRequest code

    if stream.write_all(&req).await.is_err() {
        return None;
    }

    let mut resp = [0u8; 1];
    let n = match tokio::time::timeout(Duration::from_secs(3), stream.read(&mut resp)).await {
        Ok(Ok(n)) => n,
        _ => 0,
    };

    if n == 1 {
        match resp[0] {
            b'S' => return Some("PostgreSQL (ssl)".to_string()),
            b'N' => return Some("PostgreSQL".to_string()),
            _ => return Some(format!("Postgres? (resp={})", resp[0])),
        }
    }
    None
}

/// =======================
/// MongoDB - 使用 legacy OP_QUERY 向 admin.$cmd 发送 {"isMaster":1}
/// OP_QUERY 格式 (简化):
/// int32 totalLen, int32 requestID, int32 responseTo(0), int32 opCode(2004),
/// cstring fullCollectionName ("admin.$cmd\0"), int32 numberToSkip(0), int32 numberToReturn(1), BSON document
pub fn build_mongo_is_master_request(request_id: i32) -> Vec<u8> {
    // BSON {"isMaster": 1}
    // BSON doc: int32 length, byte type 0x10 (int32), cstring "isMaster", int32 1, 0x00
    let mut doc: Vec<u8> = Vec::new();
    // placeholder for doc length
    doc.extend_from_slice(&0i32.to_le_bytes());
    // int32 field type (0x10) + name + null + value
    doc.push(0x10);
    doc.extend_from_slice(b"isMaster\0");
    doc.extend_from_slice(&1i32.to_le_bytes()); // value
    doc.push(0x00); // terminator
    // write doc length
    let doc_len = doc.len() as i32;
    doc[0..4].copy_from_slice(&doc_len.to_le_bytes());

    let mut buf: Vec<u8> = Vec::new();
    // totalLen placeholder
    buf.extend_from_slice(&0i32.to_le_bytes());
    buf.extend_from_slice(&request_id.to_le_bytes());
    buf.extend_from_slice(&0i32.to_le_bytes()); // responseTo
    buf.extend_from_slice(&2004i32.to_le_bytes()); // opCode OP_QUERY
    buf.extend_from_slice(b"admin.$cmd\0");
    buf.extend_from_slice(&0i32.to_le_bytes()); // numberToSkip
    buf.extend_from_slice(&1i32.to_le_bytes()); // numberToReturn
    buf.extend_from_slice(&doc);

    // fill totalLen
    let total_len = buf.len() as i32;
    buf[0..4].copy_from_slice(&total_len.to_le_bytes());
    buf
}

pub async fn probe_mongo(addr: &str) -> Option<String> {
    let mut stream =
        match tokio::time::timeout(Duration::from_secs(3), TcpStream::connect(addr)).await {
            Ok(Ok(s)) => s,
            _ => return None,
        };

    let req = build_mongo_is_master_request(1);
    if stream.write_all(&req).await.is_err() {
        return None;
    }

    // 读取一定字节判断是否为 mongo 响应（包含 opcode reply 或 bson doc）
    let mut buf = vec![0u8; 4096];
    let n = match tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        Ok(Ok(n)) if n > 0 => n,
        _ => return None,
    };

    // MongoDB reply starts with int32 total length (little endian) and opCode 1? reply has opCode 1 / 2004 etc.
    if n >= 16 {
        // quick heuristic: if bytes 12..16 (opCode) are 1 (OP_REPLY) or 2013 (OP_MSG) etc.
        let op_code = i32::from_le_bytes([buf[12], buf[13], buf[14], buf[15]]);
        if op_code == 1 || op_code == 2013 || op_code == 2004 || op_code == 2011 {
            return Some("MongoDB".to_string());
        }
    }
    // also fallback: if body contains "isMaster" or "ismaster"
    if let Ok(s) = std::str::from_utf8(&buf[..n]) {
        if s.to_ascii_lowercase().contains("ismaster") || s.to_ascii_lowercase().contains("ok") {
            return Some("MongoDB".to_string());
        }
    }
    None
}

/// =======================
/// 其它轻量 probe：SSH/SMTP/FTP/Redis
pub async fn probe_ssh_banner(mut stream: TcpStream) -> Option<String> {
    let mut buf = vec![0u8; 256];
    if let Ok(Ok(n)) = tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        if n > 0 {
            if let Ok(s) = std::str::from_utf8(&buf[..n]) {
                if s.starts_with("SSH-") {
                    return Some(s.lines().next().unwrap_or(s).trim().to_string());
                }
            } else {
                return Some(extract_banner_text(&buf[..n]));
            }
        }
    }
    None
}

pub async fn probe_smtp(mut stream: TcpStream) -> Option<String> {
    let mut buf = vec![0u8; 512];
    if let Ok(Ok(n)) = tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        if n > 0 {
            let s = String::from_utf8_lossy(&buf[..n]).to_string();
            return Some(s.lines().next().unwrap_or(&s).to_string());
        }
    }
    let _ = stream.write_all(b"EHLO example.com\r\n").await;
    let mut buf2 = vec![0u8; 512];
    if let Ok(Ok(n)) = tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf2)).await {
        if n > 0 {
            let s = String::from_utf8_lossy(&buf2[..n]).to_string();
            return Some(s.lines().next().unwrap_or(&s).to_string());
        }
    }
    None
}

pub async fn probe_ftp(mut stream: TcpStream) -> Option<String> {
    let mut buf = vec![0u8; 512];
    if let Ok(Ok(n)) = tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        if n > 0 {
            let s = String::from_utf8_lossy(&buf[..n]).to_string();
            return Some(s.lines().next().unwrap_or(&s).to_string());
        }
    }
    None
}

pub async fn probe_redis(mut stream: TcpStream) -> Option<String> {
    let _ = stream.write_all(b"*1\r\n$4\r\nPING\r\n").await;
    let mut buf = vec![0u8; 128];
    if let Ok(Ok(n)) = tokio::time::timeout(Duration::from_secs(3), stream.read(&mut buf)).await {
        if n > 0 {
            let s = String::from_utf8_lossy(&buf[..n]).to_string();
            return Some(s.trim().to_string());
        }
    }
    None
}



/// 把多行 banner 清理成单行：去掉 \r\n、把多重空白压缩为单空格、并 trim
pub fn normalize_banner(raw: &str) -> String {
    raw.replace('\r', " ")
        .replace('\n', " ")
        .split_whitespace()
        .collect::<Vec<_>>()
        .join(" ")
        .trim()
        .to_string()
}

/// 从 HTTP 响应（header+部分 body）提取 <title>（尽量在前面几 KB 中查找）
/// 返回 String（已去除换行与多余空格），若找不到返回 None
pub fn extract_title_from_http_response(resp: &str) -> Option<String> {
    let lower = resp.to_ascii_lowercase();

    // 找 body 部分
    if let Some(idx) = lower.find("<title") {
        if let Some(end) = lower[idx..].find("</title>") {
            let snippet = &resp[idx..idx + end];
            // 去掉 <title> 标签本身
            if let Some(gt) = snippet.find('>') {
                return Some(snippet[gt + 1..].trim().replace("\n", " "));
            }
        }
    }
    None
}

pub struct HttpProbeResult {
    pub status: Option<String>,
    pub server: Option<String>,
    pub content_type: Option<String>,
    pub title: Option<String>,
}

pub fn parse_http_response(resp: &str) -> HttpProbeResult {
    let mut status = None;
    let mut server = None;
    let mut content_type = None;

    for line in resp.lines() {
        let l = line.to_ascii_lowercase();
        if l.starts_with("http/") && status.is_none() {
            // e.g. "HTTP/1.1 200 OK"
            if let Some(code) = line.split_whitespace().nth(1) {
                status = Some(code.to_string());
            }
        } else if l.starts_with("server:") && server.is_none() {
            server = Some(line.splitn(2, ':').nth(1).unwrap_or("").trim().to_string());
        } else if l.starts_with("content-type:") && content_type.is_none() {
            content_type = Some(line.splitn(2, ':').nth(1).unwrap_or("").trim().to_string());
        }
    }

    HttpProbeResult {
        status,
        server,
        content_type,
        title: extract_title_from_http_response(resp),
    }
}


pub async fn read_full_response<S: AsyncReadExt + Unpin>(
    stream: &mut S,
    buf_size: usize,
    timeout: Duration,
) -> Option<String> {
    let mut buf = vec![0u8; buf_size];
    let mut data = Vec::new();
    loop {
        match tokio::time::timeout(timeout, stream.read(&mut buf)).await {
            Ok(Ok(0)) => break, // 连接关闭
            Ok(Ok(n)) => data.extend_from_slice(&buf[..n]),
            _ => break, // 超时或错误
        }
    }
    if data.is_empty() {
        None
    } else {
        Some(String::from_utf8_lossy(&data).to_string())
    }
}
