use chromiumoxide::browser::{Browser, BrowserConfig, HeadlessMode};
use chromiumoxide::cdp::browser_protocol::emulation::SetDeviceMetricsOverrideParams;
use chromiumoxide::cdp::browser_protocol::network::SetUserAgentOverrideParams;
use chromiumoxide::page::ScreenshotParams;
use clap::Parser;
use futures::stream::StreamExt;
use std::error::Error;
use std::fs;
use std::time::Duration;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;
use tokio::time::timeout;

#[derive(Parser, Debug)]
pub struct ScreenshotArgs {
    /// åŒ…å«URLåˆ—è¡¨çš„æ–‡ä»¶è·¯å¾„
    #[arg(short, long)]
    pub url_file: String,

    /// è¾“å‡ºç›®å½•
    #[arg(short, long, default_value = "screenshots")]
    pub output: String,
}

pub async fn run(args: &ScreenshotArgs) -> Result<(), Box<dyn Error + Send + Sync>> {
    // è¯»å– URL åˆ—è¡¨
    let content = fs::read_to_string(&args.url_file)?;
    let urls: Vec<&str> = content
        .lines()
        .filter(|l| !l.trim().is_empty() && l.starts_with("http"))
        .collect();

    if urls.is_empty() {
        return Err("æœªæ‰¾åˆ°åˆæ³• URL".into());
    }

    // åˆ›å»ºè¾“å‡ºç›®å½•
    fs::create_dir_all(&args.output)?;

    // å¯åŠ¨ Chromium
    let (mut browser, mut handler) = Browser::launch(
        BrowserConfig::builder()
            .chrome_executable("C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe")
            .no_sandbox()
            .headless_mode(HeadlessMode::True)
            .args(vec![
                "--disable-blink-features=AutomationControlled".to_string(),
                "--disable-infobars".to_string(),
                "--disable-web-security".to_string(),
                "--allow-running-insecure-content".to_string(),
                "--start-maximized".to_string(),
            ])
            .build()?,
    )
        .await?;

    tokio::spawn(async move { while let Some(_) = handler.next().await {} });

    // å¾ªç¯å¤„ç†æ¯ä¸ª URL
    for (i, url) in urls.iter().enumerate() {
        println!("ğŸ“· æ­£åœ¨æˆªå›¾: {url}");

        let page = match browser.new_page(*url).await {
            Ok(page) => page,
            Err(e) => {
                eprintln!("âŒ åˆ›å»ºé¡µé¢å¤±è´¥: {e}");
                continue;
            }
        };

        let result = async {
            // å¿…é¡»åœ¨é¡µé¢åŠ è½½å‰è®¾ç½® UA å’Œè®¾å¤‡æ¨¡æ‹Ÿå‚æ•°
            page.execute(
                SetUserAgentOverrideParams::builder()
                    .user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
                    .build()?
            ).await?;

            page.execute(
                SetDeviceMetricsOverrideParams::builder()
                    .width(1920)
                    .height(1080)
                    .device_scale_factor(1.0)
                    .mobile(false)
                    .build()?
            ).await?;

            // âœ… åŠ ï¼šæœ€å¤§ç­‰å¾… 15 ç§’ç­‰å¾… body å‡ºç°
            if let Err(_) = timeout(Duration::from_secs(15), page.wait_for_navigation()).await {
                return Err("â° é¡µé¢åŠ è½½è¶…æ—¶".into());
            }

            // âœ… åŠ ï¼šç¡®ä¿ readyState=complete
            for _ in 0..10 {
                let state: String = page.evaluate("document.readyState").await?.into_value()?;
                if state == "complete" {
                    break;
                }
                tokio::time::sleep(Duration::from_millis(500)).await;
            }

            // âœ… åŠ ï¼šè‡ªåŠ¨æ»šåŠ¨ï¼Œè§¦å‘æ‡’åŠ è½½
            let scroll_script = r#"
                (async function() {
                    await new Promise((resolve) => {
                        let totalHeight = 0;
                        const distance = 500;
                        const timer = setInterval(() => {
                            window.scrollBy(0, distance);
                            totalHeight += distance;
                            if (totalHeight >= document.body.scrollHeight) {
                                clearInterval(timer);
                                resolve();
                            }
                        }, 200);
                    });
                })();
            "#;
            let _ = page.evaluate(scroll_script).await?;

            // âœ… ç­‰æ»šåŠ¨åŠ¨ç”»
            tokio::time::sleep(Duration::from_secs(2)).await;

            // âœ… é¢å¤–åçˆ¬è®¾ç½®
            page.evaluate(r#"
                Object.defineProperty(navigator, 'webdriver', { get: () => false });
                Object.defineProperty(navigator, 'languages', { get: () => ['zh-CN', 'zh'] });
                Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3] });
                window.chrome = { runtime: {} };
                window.dispatchEvent(new Event('mousemove'));
                window.dispatchEvent(new Event('scroll'));
            "#).await?;

            // âœ… æˆªæ•´ä¸ªé¡µé¢
            let bytes = page
                .screenshot(ScreenshotParams::builder().full_page(true).build())
                .await?;

            let filename = format!("{}/{}.png", &args.output, i + 1);
            let mut file = File::create(&filename).await?;
            file.write_all(&bytes).await?;

            Ok::<_, Box<dyn Error + Send + Sync>>(filename)
        }
            .await;

        if let Err(e) = page.close().await {
            eprintln!("âš ï¸ å…³é—­é¡µé¢å¤±è´¥: {e}");
        }

        match result {
            Ok(filename) => println!("âœ… æˆªå›¾å®Œæˆ: {filename}"),
            Err(e) => eprintln!("âŒ æˆªå›¾å¤±è´¥: {e}"),
        }
    }

    if let Err(e) = browser.close().await {
        eprintln!("âš ï¸ å…³é—­æµè§ˆå™¨å¤±è´¥: {e}");
    }

    Ok(())
}
