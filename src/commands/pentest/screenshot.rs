use chromiumoxide::browser::{Browser, BrowserConfig, HeadlessMode};
use chromiumoxide::cdp::browser_protocol::emulation::SetDeviceMetricsOverrideParams;
use chromiumoxide::cdp::browser_protocol::network::SetUserAgentOverrideParams;
use chromiumoxide::page::{Page, ScreenshotParams};
use clap::Parser;
use futures::stream;
use futures::stream::StreamExt;
use std::error::Error;
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::time::Duration;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;
use tokio::time::timeout;
use uuid::Uuid;

#[derive(Parser, Debug, Clone)]
pub struct ScreenshotArgs {
    /// ÂåÖÂê´URLÂàóË°®ÁöÑÊñá‰ª∂Ë∑ØÂæÑ
    #[arg(short, long)]
    pub url_file: String,

    /// ËæìÂá∫ÁõÆÂΩï
    #[arg(short, long, default_value = "screenshots")]
    pub output: String,

    /// Âπ∂Âèë‰ªªÂä°Êï∞
    #[arg(long, default_value = "4")]
    pub concurrency: usize,

    /// ÊåáÂÆöÊó†Â§¥ÊµèËßàÂô®‰ΩçÁΩÆ„ÄÇ
    #[arg(long, default_value = "./chromiumoxide/chrome.exe")]
    pub path: String,
}

fn sanitize_filename(url: &str) -> String {
    url.replace("://", "_")
        .replace("/", "_")
        .replace("?", "_")
        .replace("&", "_")
        .replace("=", "_")
        .replace(":", "_")
}

pub async fn run(args: &ScreenshotArgs) -> Result<(), Box<dyn Error + Send + Sync>> {
    let content = fs::read_to_string(&args.url_file)?;
    let urls: Vec<String> = content
        .lines()
        .filter(|l| !l.trim().is_empty() && l.starts_with("http"))
        .map(|s| s.trim().to_string())
        .collect();

    if urls.is_empty() {
        return Err("Êú™ÊâæÂà∞ÂêàÊ≥ï URL".into());
    }

    fs::create_dir_all(&args.output)?;

    let user_data_dir = std::env::temp_dir()
        .join("chromiumoxide")
        .join(Uuid::new_v4().to_string());

    let chrome_path = PathBuf::from(&args.path)
        .canonicalize()
        .expect("Êó†Ê≥ïËß£Êûê Chrome Ë∑ØÂæÑ");

    let (browser, mut handler) = Browser::launch(
        BrowserConfig::builder()
            .chrome_executable(chrome_path)
            .no_sandbox()
            .headless_mode(HeadlessMode::True)
            .user_data_dir(user_data_dir)
            .args(vec![
                "--disable-blink-features=AutomationControlled".to_string(),
                "--disable-infobars".to_string(),
                "--disable-web-security".to_string(),
                "--allow-running-insecure-content".to_string(),
                "--start-maximized".to_string(),
                "--remote-debugging-port=0".to_string(),
            ])
            .build()?,
    )
    .await?;

    // ÊåÅÁª≠Â§ÑÁêÜÊµèËßàÂô®‰∫ã‰ª∂
    tokio::spawn(async move {
        while let Some(evt) = handler.next().await {
            if let Err(e) = evt {
                eprintln!("üö® Browser event error: {:?}", e);
            }
        }
    });

    let browser = Arc::new(browser);
    let output = Arc::new(args.output.clone());

    // ‰ΩøÁî® FuturesUnordered Âπ∂ÂèëÊà™Âõæ
    stream::iter(urls.into_iter().enumerate())
        .for_each_concurrent(Some(args.concurrency), |(_i, url)| {
            let browser = Arc::clone(&browser);
            let output = Arc::clone(&output);

            async move {
                println!("üì∑ Ê≠£Âú®Êà™Âõæ: {url}");
                match browser.new_page(&url).await {
                    Ok(page) => match screenshot_page(page, &output, &url).await {
                        Ok(path) => println!("‚úÖ Êà™ÂõæÂÆåÊàê: {}", path.display()),
                        Err(e) => eprintln!("‚ùå Êà™ÂõæÂ§±Ë¥•: {e}"),
                    },
                    Err(e) => eprintln!("‚ùå ÂàõÂª∫È°µÈù¢Â§±Ë¥•: {e}"),
                }
            }
        })
        .await;

    match Arc::try_unwrap(browser) {
        Ok(mut browser) => {
            if let Err(e) = browser.close().await {
                eprintln!("‚ö†Ô∏è ÂÖ≥Èó≠ÊµèËßàÂô®Â§±Ë¥•: {e}");
            }
        }
        Err(_) => {
            eprintln!("‚ö†Ô∏è Êó†Ê≥ïÂÖ≥Èó≠ÊµèËßàÂô®ÔºöËøòÊúâÂÖ∂‰ªñÂºïÁî®Â≠òÂú®");
        }
    }

    Ok(())
}

async fn screenshot_page(
    page: Page,
    output_dir: &str,
    url: &str,
) -> Result<PathBuf, Box<dyn Error + Send + Sync>> {
    page.execute(
        SetUserAgentOverrideParams::builder()
            .user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
            .build()?,
    ).await?;

    page.execute(
        SetDeviceMetricsOverrideParams::builder()
            .width(1920)
            .height(1080)
            .device_scale_factor(1.0)
            .mobile(false)
            .build()?,
    )
    .await?;

    if timeout(Duration::from_secs(15), page.find_element("body"))
        .await
        .is_err()
    {
        return Err("‚è∞ È°µÈù¢Âä†ËΩΩË∂ÖÊó∂".into());
    }

    for _ in 0..10 {
        let state: String = page.evaluate("document.readyState").await?.into_value()?;
        if state == "complete" {
            break;
        }
        tokio::time::sleep(Duration::from_millis(500)).await;
    }

    let scroll_script = r#"
        (async function() {
            await new Promise((resolve) => {
                let totalHeight = 0;
                const distance = 500;
                const timer = setInterval(() => {
                    window.scrollBy(0, distance);
                    totalHeight += distance;
                    if (totalHeight >= document.body.scrollHeight) {
                        clearInterval(timer);
                        resolve();
                    }
                }, 200);
            });
        })();
    "#;
    let _ = page.evaluate(scroll_script).await?;
    tokio::time::sleep(Duration::from_secs(2)).await;

    page.evaluate(
        r#"
        Object.defineProperty(navigator, 'webdriver', { get: () => false });
        Object.defineProperty(navigator, 'languages', { get: () => ['zh-CN', 'zh'] });
        Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3] });
        window.chrome = { runtime: {} };
        window.dispatchEvent(new Event('mousemove'));
        window.dispatchEvent(new Event('scroll'));
    "#,
    )
    .await?;

    let bytes = page
        .screenshot(ScreenshotParams::builder().full_page(true).build())
        .await?;

    let filename = sanitize_filename(url);
    let filepath = Path::new(output_dir).join(format!("{filename}.png"));

    let mut file = File::create(&filepath).await?;
    file.write_all(&bytes).await?;

    if let Err(e) = page.close().await {
        eprintln!("‚ö†Ô∏è ÂÖ≥Èó≠È°µÈù¢Â§±Ë¥•: {e}");
    }

    Ok(filepath)
}
