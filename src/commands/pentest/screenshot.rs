use chromiumoxide::browser::{Browser, BrowserConfig, HeadlessMode};
use chromiumoxide::cdp::browser_protocol::emulation::SetDeviceMetricsOverrideParams;
use chromiumoxide::cdp::browser_protocol::network::SetUserAgentOverrideParams;
use chromiumoxide::page::ScreenshotParams;
use clap::Parser;
use futures::stream::StreamExt;
use std::error::Error;
use std::fs;
use std::time::Duration;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;
use tokio::time::timeout;

#[derive(Parser, Debug)]
pub struct ScreenshotArgs {
    /// 包含URL列表的文件路径
    #[arg(short, long)]
    pub url_file: String,

    /// 输出目录
    #[arg(short, long, default_value = "screenshots")]
    pub output: String,
}

pub async fn run(args: &ScreenshotArgs) -> Result<(), Box<dyn Error + Send + Sync>> {
    // 读取 URL 列表
    let content = fs::read_to_string(&args.url_file)?;
    let urls: Vec<&str> = content
        .lines()
        .filter(|l| !l.trim().is_empty() && l.starts_with("http"))
        .collect();

    if urls.is_empty() {
        return Err("未找到合法 URL".into());
    }

    // 创建输出目录
    fs::create_dir_all(&args.output)?;

    // 启动 Chromium
    let (mut browser, mut handler) = Browser::launch(
        BrowserConfig::builder()
            .chrome_executable("C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe")
            .no_sandbox()
            .headless_mode(HeadlessMode::True)
            .args(vec![
                "--disable-blink-features=AutomationControlled".to_string(),
                "--disable-infobars".to_string(),
                "--disable-web-security".to_string(),
                "--allow-running-insecure-content".to_string(),
                "--start-maximized".to_string(),
            ])
            .build()?,
    )
        .await?;

    tokio::spawn(async move { while let Some(_) = handler.next().await {} });

    // 循环处理每个 URL
    for (i, url) in urls.iter().enumerate() {
        println!("📷 正在截图: {url}");

        let page = match browser.new_page(*url).await {
            Ok(page) => page,
            Err(e) => {
                eprintln!("❌ 创建页面失败: {e}");
                continue;
            }
        };

        let result = async {
            // 必须在页面加载前设置 UA 和设备模拟参数
            page.execute(
                SetUserAgentOverrideParams::builder()
                    .user_agent("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
                    .build()?
            ).await?;

            page.execute(
                SetDeviceMetricsOverrideParams::builder()
                    .width(1920)
                    .height(1080)
                    .device_scale_factor(1.0)
                    .mobile(false)
                    .build()?
            ).await?;

            // ✅ 加：最大等待 15 秒等待 body 出现
            if let Err(_) = timeout(Duration::from_secs(15), page.wait_for_navigation()).await {
                return Err("⏰ 页面加载超时".into());
            }

            // ✅ 加：确保 readyState=complete
            for _ in 0..10 {
                let state: String = page.evaluate("document.readyState").await?.into_value()?;
                if state == "complete" {
                    break;
                }
                tokio::time::sleep(Duration::from_millis(500)).await;
            }

            // ✅ 加：自动滚动，触发懒加载
            let scroll_script = r#"
                (async function() {
                    await new Promise((resolve) => {
                        let totalHeight = 0;
                        const distance = 500;
                        const timer = setInterval(() => {
                            window.scrollBy(0, distance);
                            totalHeight += distance;
                            if (totalHeight >= document.body.scrollHeight) {
                                clearInterval(timer);
                                resolve();
                            }
                        }, 200);
                    });
                })();
            "#;
            let _ = page.evaluate(scroll_script).await?;

            // ✅ 等滚动动画
            tokio::time::sleep(Duration::from_secs(2)).await;

            // ✅ 额外反爬设置
            page.evaluate(r#"
                Object.defineProperty(navigator, 'webdriver', { get: () => false });
                Object.defineProperty(navigator, 'languages', { get: () => ['zh-CN', 'zh'] });
                Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3] });
                window.chrome = { runtime: {} };
                window.dispatchEvent(new Event('mousemove'));
                window.dispatchEvent(new Event('scroll'));
            "#).await?;

            // ✅ 截整个页面
            let bytes = page
                .screenshot(ScreenshotParams::builder().full_page(true).build())
                .await?;

            let filename = format!("{}/{}.png", &args.output, i + 1);
            let mut file = File::create(&filename).await?;
            file.write_all(&bytes).await?;

            Ok::<_, Box<dyn Error + Send + Sync>>(filename)
        }
            .await;

        if let Err(e) = page.close().await {
            eprintln!("⚠️ 关闭页面失败: {e}");
        }

        match result {
            Ok(filename) => println!("✅ 截图完成: {filename}"),
            Err(e) => eprintln!("❌ 截图失败: {e}"),
        }
    }

    if let Err(e) = browser.close().await {
        eprintln!("⚠️ 关闭浏览器失败: {e}");
    }

    Ok(())
}
