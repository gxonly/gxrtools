use clap::Parser;
use reqwest::Client;
use std::error::Error;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::time::Instant;
use tokio::task;

#[derive(Parser, Debug)]
pub struct UrlScan {
    /// ç›®æ ‡ URLï¼Œå¦‚ http://example.com
    #[arg(short, long, conflicts_with = "urls")]
    pub url: Option<String>,

    /// URLåˆ—è¡¨ï¼Œé»˜è®¤ url.txt
    #[arg(long, conflicts_with = "url", default_value = "url.txt")]
    pub urls: String,

    /// å­—å…¸æ–‡ä»¶è·¯å¾„
    #[arg(short, long, default_value = "urlscan.txt")]
    pub dict: String,
}

pub async fn run(args: &UrlScan) -> Result<(), Box<dyn Error + Send + Sync>> {
    let start = Instant::now();

    let targets = if let Some(single_url) = &args.url {
        vec![normalize_url(single_url)]
    } else {
        read_lines(&args.urls)?
            .into_iter()
            .map(|url| normalize_url(&url))
            .collect()
    };

    let dict_paths = read_lines(&args.dict)?;

    let mut handles = vec![];

    for target in targets {
        let client = Client::builder()
            .timeout(std::time::Duration::from_secs(5))
            .build()?;
        let dict_paths = dict_paths.clone();

        let handle = task::spawn(scan_target(target, dict_paths, client));
        handles.push(handle);
    }

    for handle in handles {
        handle.await??;
    }

    println!("âœ… æ‰€æœ‰æ¢æµ‹å®Œæˆ");
    println!("â±ï¸ æ€»è€—æ—¶ï¼š{:.2?}", start.elapsed());
    Ok(())
}

fn normalize_url(url: &str) -> String {
    let mut url = url.trim().to_string();

    if !url.starts_with("http://") && !url.starts_with("https://") {
        url = format!("https://{}", url);
    }

    if url.ends_with('/') {
        url.pop();
    }

    url
}

fn read_lines(path: &str) -> Result<Vec<String>, Box<dyn Error + Send + Sync>> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    let mut urls = Vec::new();

    for line in reader.lines() {
        let line = line?;
        let line = line.trim();
        if !line.is_empty() {
            urls.push(line.to_string());
        }
    }

    Ok(urls)
}

async fn scan_target(
    base_url: String,
    paths: Vec<String>,
    client: Client,
) -> Result<(), Box<dyn Error + Send + Sync>> {
    println!("ğŸš€ å¼€å§‹æ¢æµ‹: {}", base_url);
    let mut found = Vec::new();

    for path in paths {
        let full_url = format!("{}/{}", base_url, path);

        match client.get(&full_url).send().await {
            Ok(resp) => {
                let status = resp.status();
                if status.is_success() || status.as_u16() == 403 {
                    println!("[+] å‘ç°è·¯å¾„: {} [{}]", full_url, status);
                    found.push((full_url, status.as_u16()));
                }
            }
            Err(_) => {}
        }
    }

    println!("ğŸ” {} æ¢æµ‹ç»“æŸï¼Œå…±å‘ç° {} ä¸ªæœ‰æ•ˆè·¯å¾„", base_url, found.len());
    Ok(())
}
