use clap::Parser;
use reqwest::Client;
use std::error::Error;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::time::Instant;

#[derive(Parser, Debug)]
pub struct UrlScan {
    /// ç›®æ ‡ URLï¼Œå¦‚ http://example.com
    #[arg(short, long)]
    pub url: String,

    /// å­—å…¸æ–‡ä»¶è·¯å¾„
    #[arg(short, long, default_value = "urlscan.txt")]
    pub dict: String,
}

pub async fn run(args: &UrlScan) -> Result<(), Box<dyn Error + Send + Sync>> {
    let start = Instant::now();
    let client = Client::builder()
        .timeout(std::time::Duration::from_secs(5))
        .build()?;

    let file = File::open(&args.dict)?;
    let reader = BufReader::new(file);

    println!("ğŸš€ å¼€å§‹è·¯å¾„æ¢æµ‹ï¼š{}", args.url);

    let mut found = Vec::new();

    for line in reader.lines() {
        let path = match line {
            Ok(p) => p.trim().to_string(),
            Err(_) => continue,
        };
        if path.is_empty() {
            continue;
        }

        let full_url = format!("{}/{}", args.url.trim_end_matches('/'), path);

        match client.get(&full_url).send().await {
            Ok(resp) => {
                let status = resp.status();
                if status.is_success() || status.as_u16() == 403 {
                    println!("[+] å‘ç°è·¯å¾„: {} [{}]", full_url, status);
                    found.push((full_url, status.as_u16()));
                }
            }
            Err(_) => {}
        }
    }

    println!("âœ… æ¢æµ‹å®Œæˆï¼Œå…±å‘ç° {} ä¸ªæœ‰æ•ˆè·¯å¾„", found.len());
    println!("â±ï¸ æ€»è€—æ—¶ï¼š{:.2?}", start.elapsed());

    Ok(())
}
