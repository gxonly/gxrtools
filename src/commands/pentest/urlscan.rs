use clap::Parser;
use reqwest::Client;
use std::error::Error;
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::time::Instant;

#[derive(Parser, Debug)]
pub struct UrlScan {
    /// 目标 URL，如 http://example.com
    #[arg(short, long)]
    pub url: String,

    /// 字典文件路径
    #[arg(short, long, default_value = "urlscan.txt")]
    pub dict: String,
}

pub async fn run(args: &UrlScan) -> Result<(), Box<dyn Error + Send + Sync>> {
    let start = Instant::now();
    let client = Client::builder()
        .timeout(std::time::Duration::from_secs(5))
        .build()?;

    let file = File::open(&args.dict)?;
    let reader = BufReader::new(file);

    println!("🚀 开始路径探测：{}", args.url);

    let mut found = Vec::new();

    for line in reader.lines() {
        let path = match line {
            Ok(p) => p.trim().to_string(),
            Err(_) => continue,
        };
        if path.is_empty() {
            continue;
        }

        let full_url = format!("{}/{}", args.url.trim_end_matches('/'), path);

        match client.get(&full_url).send().await {
            Ok(resp) => {
                let status = resp.status();
                if status.is_success() || status.as_u16() == 403 {
                    println!("[+] 发现路径: {} [{}]", full_url, status);
                    found.push((full_url, status.as_u16()));
                }
            }
            Err(_) => {}
        }
    }

    println!("✅ 探测完成，共发现 {} 个有效路径", found.len());
    println!("⏱️ 总耗时：{:.2?}", start.elapsed());

    Ok(())
}
